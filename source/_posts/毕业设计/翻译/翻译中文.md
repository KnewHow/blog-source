---
title: 毕业论文翻译 -中文
date: 2018/05/07
categories: 毕业论文
tags:
- 毕业论文
---

# Scala 宏 —— 让我们的力量变得更强
—— 拥有着丰富语法特性和类型检查的元编程技术
作者：Eugene Burmako
学校：瑞士洛桑联邦理工学院
联系邮箱：eugene.burmako@epfl.ch

# 摘要
编译时期的元编程技术已经逐步被证明是一个非常有用技术，它可以在语言的虚拟化、语言外部扩展DSL(特定领域语言)、自身代码优化、以及模板代码的产生方面发挥很大的作用。在最近发布的 Scala 2.10 版本中，我们已经介绍了宏技术，它作为一个实验性的工具，提供给使用者编译时期的元编程能力。在提供 Scala 宏的同时，我们介绍了宏的一些其它用法，这些用法将会给使用者提供不同的与 Scala 编译器交互的接口和能力。

在这篇文章中，我们将会展现 Scala 宏的语法特性和静态类型。我们将会通过一些列的例子来学习宏的使用(其中有一些是产品化系统)，例如语言的虚拟化，类型的提供器，类型类的具体实例化，类型层面的编程以及外部的特定领域语言的扩展。我们将会探索宏新的和独特的使用方式相比于之前已经存在的编程语言，例如隐式转换，动态调用，注解，字符串插值和其它一些新的特性。这些新的特性将会更加开放的作用于软件开发所面对的挑战。

# 分类和主题的描述
编程语言的结构和特色。

# 总体的分类
编程语言

# 关键字
编译时期的元编程，类型类，特定领域语言，Scala

# 介绍
编译时期的元编程可以被理解为在编译时期处理程序的算法和数据结构。它的目标是为了让程序员自动的产生一些程序的代码而不是自己手动去写。因此，元编程是一段拥有其它程序信息的程序，并且可以操作其它程序。
通过对编程语言和编程类型的研究，证明了元编程在编程领域是非常有用的。例如在语言的虚拟化(重载或者重写原始是编程语言代码)，内嵌外部的特定领域语言(密封性的集成其它的编程语言到自己语言的本身)，自身代码的优化(分析程序本身的代码进行优化)，模板代码的产生(自动去重复那些不是很容易被抽取的底层代码的模板)。
在最近的 Scala 2.10 的产品中，我们已经介绍了 Scala 的宏技术——一个新的实验性的语言特色。Scala 把它认为是编译时期的元编程技术。这里元编程技术的亮点是可以让 Scala 的编译器认识一些在 Scala 代码中的方法，或者称这些方法为宏。宏其实就是在编译时期可以被编译器执行的一些方法。当宏被执行的时候，编译器可以提供给宏一个上下文对象。这个对象拥有着编译器处理代码的一些能力，如解析，类型检查和错误信息的报告。宏可以调用这些可用的编译器的 API 来影响代码的编译。例如调整被编译的代码或者控制类型检查器的接口。

在 Scala 中，元编程最基本的表现形式是`定义宏`，你可以把它理解为定义普通的方法，只不过在它们被调用时，进行的是宏展开。除了定义宏之外，我们也确认了，实现了和实验了其它宏的表现形式，如：动态的宏，字符串的内嵌，隐式的宏，类型宏以及注解宏。它们中的每一个都包含不同宏的表现形式。并且可以被用户使用。我们将会继续去探索那些被认为是非常困难或者不可实现的宏的表现形式。

我们的主要贡献如下：
* 设计和实现了表现形式不同的宏，这些宏以一种原则的方式集成到 Scala 的语法特性和静态的类型系统中。
* 通过很多研究性的例子来多方面的校验这些宏。演示了很多宏的用法：
  * (a) 宏可以让编程语言产生虚拟化
  * (b) 宏可以实现某种形式的类型产生器
  * (c) 宏可以被用来自动的产生类型类的实例
  * (d) 宏可以简化类型层面的编程
  * (e) 宏可以外部的扩展特定领域语言
此外我们继续展现了宏可以实现一些不可思议的语法特性，例如代码的消除和实例化类型类。

剩下的章节需要按照下面的方式进行组织。第二章将会简单介绍 Scala 的宏，第三章将会介绍我们验证过的一些宏的表现形式，为第四章埋下伏笔。在第四章，我们将会概览宏表现形式的一些用例，我们将会通过例子来表现这些宏可以做什么以及讨论其它可以达到相同功能的替换方式。在这篇文章中，我们将刻意避免深入我们宏系统的细节（如，语义的扩展，类型检测器的集成，代码的健壮性，以及宏与宏之间的相互操作）为了我们可以更好的集中精力去研究如何在 Scala 的语法特性上和静态的类型系统上使用宏。

# 一种直观的表现
为了去了解 Scala 的元编程技术，让我们去探索最简单的 Scala 宏的使用方式——定义宏。定义宏这种用法的思想灵感来自于 `Lisp` 和 `Nemerle`。定义宏可以理解为和定义一个普通的方法差不多，只不过这个方法是在编译时期被调用并且进行宏展开。这里的宏展开其实就是把宏方法和它的参数转换为另一种代码片段。
在宏定义中存在一个上下文对象，它提供了一个不透明的类型代码片段用来表示那些没有类型的代码片段。同时这个上下文对象也暴露了宏应用的方法，这些方法的返回值将会被宏展开。上下文对象还定义了一个以`q`为标志的字符串的内插器，这个内插器可以使用字符串字面量来轻易的实现创建正常意义的代码片段和模式匹配的代码片段。举个例子，`q"$x + $y"` 这个代码创建有一段 `x` 和 `y` 之和的代码片段。而 `val q"$x + $y" = z` 将会模式匹配 `z` 作为和，`x` 和 `y` 作为参数。
(译者注：其实这个`q`内插器非常了不起，因为这里都是在编译时期，`x` 和 `y` 并不是正真意义上的值，而是一棵棵语法树，用`q`创建直观意义上的代码其实是非常了不起的)

断言函数是一个非常经典的例子，它其实就是用宏来实现的。断言函数的机理就是：它会计算它一个参数里面的布尔表达式的值，如果这个值是 `false`，那么它就会报告错误信息。下面列出了断言函数的一种可能性的宏实现代码：
```Scala
def assert(cond: Boolean, msg: String) = macro assertImpl
def assertImpl(c: Context) = {
  import c.universe._
  val q"assert($cond, $msg)" = c.macroApplication
  q"if (!$cond) raise($msg)"
}
```
这里的断言函数(`assert`)其实仅仅是作为断言函数实现体(`assertImpl`)的门面，其实真正发挥作用的是断言函数的实现体，它会把断言函数转换为等价的条件语句块。举个例子，如果调用`assert(2 + 2 ==4, "does not compute")` 将会在宏展开是被替换为` if (!(2 + 2 == 4)) raise("does not compute"`

即使是在这个很简单的例子中，宏实现也可以被认为是更加有用的比起 Scala 的函数，因为宏实现不需要去计算额外的信息除非布尔表达式不满足。阻塞去计算额外的信息是从性能方面进行考虑的，因为普通的函数实现会产生很多的模板代码，而且这些模板代码也不是很容易被抽取出来。 Scala 确实也支持参数的懒加载，但是由于内联的作用，其本质还是会降低性能。使用宏可以完全解决性能的问题并且没有任何副作用。

除了定义宏，我们还设计，实现以及实验了很多宏的表现形式，这些宏将会提供不同的接口和能力来和 Scala 编译器进行相互操作。

# 进军：宏的表现形式
宏以文本的替换为理念，而为了完成这个理念，需要两个步骤，一：识别被指定的代码片段，二：执行替换操作。在宏起源的 Lisp 语言中，程序可以使用S表达式(S-expressions)来进行均匀替换，因此不论一个代码片段是否被转换，不论它是一个算法表达式还是一个函数函数声明，识别和替换都可以被一致的进行。

Scala 是一门具有丰富的语法特性和静态类型的语言，编译时期的代码转换需要区分字面量，类型，表达式和声明。这些都需要遵守一个名叫 `scalac` 的 Scala 编译器。因此这是非常有必要的去了解 Scala 文本抽取的三种的表现形式：
* 字面量的宏——扩展字面量
* 类型宏——扩展类型
* 宏注解——扩展定义

在这个章节中，我们重点介绍这三种宏和它们的表现形，并且也会展示它们和其它编程语言的一些交集。

# 定义宏
最主流的字面量宏的表现形式就是定义宏，在第二章已经简单介绍过了。对于程序员来说，定义宏和定义普通方法没什么区别，只不过是这个方法含有一个特殊的属性，这个特殊的属性就是宏定义。
