---
title: 毕业论文翻译 -英文
date: 2018/05/07
categories: 毕业论文
tags:
- 毕业论文
---

# REFLECTION
OVERVIEW

Reflection is the ability of a program to inspect, and possibly even modify itself. It has a long history across object-oriented, functional, and logic programming paradigms. While some languages are built around reflection as a guiding principle, many languages progressively evolve their reflection abilities over time.

Reflection involves the ability to reify (ie. make explicit) otherwise-implicit elements of a program. These elements can be either static program elements like classes, methods, or expressions, or dynamic elements like the current continuation or execution events such as method invocations and field accesses. One usually distinguishes between compile-time and runtime reflection depending on when the reflection process is performed. Compile-time reflection is a powerful way to develop program transformers and generators, while runtime reflection is typically used to adapt the language semantics or to support very late binding between software components.

Until 2.10, Scala has not had any reflection capabilities of its own. Instead, one could use part of the Java reflection API, namely that dealing with providing the ability to dynamically inspect classes and objects and access their members. However, many Scala-specific elements are unrecoverable under standalone Java reflection, which only exposes Java elements (no functions, no traits) and types (no existential, higher-kinded, path-dependent and abstract types). In addition, Java reflection is also unable to recover runtime type info of Java types that are generic at compile-time; a restriction that carried through to runtime reflection on generic types in Scala.

In Scala 2.10, a new reflection library was introduced not only to address the shortcomings of Java’s runtime reflection on Scala-specific and generic types, but to also add a more powerful toolkit of general reflective capabilities to Scala. Along with full-featured runtime reflection for Scala types and generics, Scala 2.10 also ships with compile-time reflection capabilities, in the form of macros, as well as the ability to reify Scala expressions into abstract syntax trees.



# MACROS
USE CASES

Since their release as an experimental feature of Scala 2.10, macros have brought previously impossible or prohibitively complex things to the realm of possible. Both commercial and research users of Scala use macros to bring their ideas to life. At EPFL we are leveraging macros to power our research. Lightbend also employs macros in a number of projects. Macros are also popular in the community and have already given rise to a number of interesting applications.

The recent talk “What Are Macros Good For?” describes and systemizes uses that macros found among Scala 2.10 users. The thesis of the talk is that macros are good for code generation, static checking and DSLs, illustrated with a number of examples from research and industry.

We have also published a paper in the Scala’13 workshop, “Scala Macros: Let Our Powers Combine!”, covering the state of the art of macrology in Scala 2.10 from a more academic point of view. In the paper we show how the rich syntax and static types of Scala synergize with macros and explore how macros enable new and unique ways to use pre-existing language features.

# What Are Macros Good For?

What are macros?
▶ An experimental feature of 2.10 and 2.11
▶ You write functions against the reflection API
▶ Compiler invokes them during compilation

Macro flavors
▶ Many ways to hook into the compiler → many macro flavors
▶ Type macros, annotation macros, untyped macros, etc
▶ However in 2.10 and 2.11 there are only def macros

Code generation
▶ Create terms and types on-the-fly
▶ More convenient and robust than textual codegen
▶ Therefore performance remains excellent

Static checks
▶ Check your program during compilation
▶ Report errors and warnings as you go

Domain-specific languages
▶ Take a program written in an internal or external DSL
▶ Work with it as with a domain-specific data structure

# DEF MACROS

Def macros are shipped as an experimental feature of Scala since version 2.10.0. A subset of def macros, pending a thorough specification, is tentatively scheduled to become stable in one of the future versions of Scala.

This guide has been written for Scala 2.10.0, and now we’re well into the Scala 2.11.x release cycle, so naturally the contents of the document are outdated. Nevertheless, this guide is not obsolete - everything written here will still work in both Scala 2.10.x and Scala 2.11.x, so it will be helpful to read it through. After reading the guide, take a look at the docs on quasiquotes and macro bundles to familiarize yourself with latest developments that dramatically simplify writing macros. Then it might be a good idea to follow our macro workshop for more in-depth examples.

## Intuition
Here is a prototypical macro definition:

```Scala
def m(x: T): R = macro implRef
```

At first glance macro definitions are equivalent to normal function definitions, except for their body, which starts with the conditional keyword macro and is followed by a possibly qualified identifier that refers to a static macro implementation method.

If, during type-checking, the compiler encounters an application of the macro m(args), it will expand that application by invoking the corresponding macro implementation method, with the abstract-syntax trees of the argument expressions args as arguments. The result of the macro implementation is another abstract syntax tree, which will be inlined at the call site and will be type-checked in turn.

The following code snippet declares a macro definition assert that references a macro implementation `Asserts.assertImpl` (definition of assertImpl is provided below):

```Scala
def assert(cond: Boolean, msg: Any) = macro Asserts.assertImpl
```

A call `assert(x < 10, "limit exceeded")` would then lead at compile time to an invocation

`assertImpl(c)(<[ x < 10 ]>, <[ “limit exceeded” ]>)`

where c is a context argument that contains information collected by the compiler at the call site, and the other two arguments are abstract syntax trees representing the two expressions `x < 10` and `limit exceeded`.

In this document, `<[ expr ]>` denotes the abstract syntax tree that represents the expression expr. This notation has no counterpart in our proposed extension of the Scala language. In reality, the syntax trees would be constructed from the types in trait `scala.reflect.api.Trees` and the two expressions above would look like this:

```Scala
Literal(Constant("limit exceeded"))
Apply(
  Select(Ident(TermName("x")), TermName("$less"),
  List(Literal(Constant(10)))))
```Scala

Here is a possible implementation of the assert macro:

```Scala
import scala.reflect.macros.Context
import scala.language.experimental.macros

object Asserts {
  def raise(msg: Any) = throw new AssertionError(msg)
  def assertImpl(c: Context)
    (cond: c.Expr[Boolean], msg: c.Expr[Any]) : c.Expr[Unit] =
   if (assertionsEnabled)
      <[ if (!cond) raise(msg) ]>
      else
      <[ () ]>
}
```

As the example shows, a macro implementation takes several parameter lists. First comes a single parameter, of type scala.reflect.macros.Context. This is followed by a list of parameters that have the same names as the macro definition parameters. But where the original macro parameter has type `T`, a macro implementation parameter has type `c.Expr[T]`. `Expr[T]` is a type defined in Context that wraps an abstract syntax tree of type `T`. The result type of the `assertImpl` macro implementation is again a wrapped tree, of type `c.Expr[Unit]`.

Also note that macros are considered an experimental and advanced feature, so in order to write macros you need to enable them. Do that either with import `scala.language.experimental.macros` on per-file basis or with `-language:experimental.macros` (providing a compiler switch) on per-compilation basis. Your users, however, don’t need to enable anything - macros look like normal methods and can be used as normal methods, without any compiler switches or additional configurations.

# Generic macros
Macro definitions and macro implementations may both be generic. If a macro implementation has type parameters, actual type arguments must be given explicitly in the macro definition’s body. Type parameters in an implementation may come with `WeakTypeTag` context bounds. In that case the corresponding type tags describing the actual type arguments instantiated at the application site will be passed along when the macro is expanded.

The following code snippet declares a macro definition `Queryable.map` that references a macro implementation `QImpl.map`:

```Scala
class Queryable[T] {
 def map[U](p: T => U): Queryable[U] = macro QImpl.map[T, U]
}

object QImpl {
 def map[T: c.WeakTypeTag, U: c.WeakTypeTag]
        (c: Context)
        (p: c.Expr[T => U]): c.Expr[Queryable[U]] = ...
}
```
Now consider a value q of type Queryable[String] and a macro call

```Scala
q.map[Int](s => s.length)
```
The call is expanded to the following reflective macro invocation

```Scala
QImpl.map(c)(<[ s => s.length ]>)
   (implicitly[WeakTypeTag[String]], implicitly[WeakTypeTag[Int]])

```

# A complete example
This section provides an end-to-end implementation of a printf macro, which validates and applies the format string at compile-time. For the sake of simplicity the discussion uses console Scala compiler, but as explained below macros are also supported by Maven and sbt.

Writing a macro starts with a macro definition, which represents the facade of the macro. Macro definition is a normal function with anything one might fancy in its signature. Its body, though, is nothing more that a reference to an implementation. As mentioned above, to define a macro one needs to import `scala.language.experimental.macros` or to enable a special compiler switch,` -language:experimental.macros`.

```Scala
import scala.language.experimental.macros
def printf(format: String, params: Any*): Unit = macro printf_impl
```

Macro implementation must correspond to macro definitions that use it (typically there’s only one, but there might also be many). In a nutshell, every parameter of type T in the signature of a macro definition must correspond to a parameter of type c.Expr[T] in the signature of a macro implementation. The full list of rules is quite involved, but it’s never a problem, because if the compiler is unhappy, it will print the signature it expects in the error message.


```Scala
import scala.reflect.macros.Context
def printf_impl(c: Context)(format: c.Expr[String], params: c.Expr[Any]*): c.Expr[Unit] = ...
```

Compiler API is exposed in `scala.reflect.macros.Context`. Its most important part, reflection API, is accessible via `c.universe`. It’s customary to import `c.universe._`, because it includes a lot of routinely used functions and types

```Scala
import c.universe._
```
First of all, the macro needs to parse the provided format string. Macros run during the compile-time, so they operate on trees, not on values. This means that the format parameter of the printf macro will be a compile-time literal, not an object of type java.lang.String. This also means that the code below won’t work for `printf(get_format(), ...)`, because in that case format won’t be a string literal, but rather an AST that represents a function application.

```Scala
val Literal(Constant(s_format: String)) = format.tree
```

Typical macros (and this macro is not an exception) need to create ASTs (abstract syntax trees) which represent Scala code. To learn more about generation of Scala code, take a look at the overview of reflection. Along with creating ASTs the code provided below also manipulates types. Note how we get a hold of Scala types that correspond to Int and String. Reflection overview linked above covers type manipulations in detail. The final step of code generation combines all the generated code into a `Block`. Note the call to `reify`, which provides a shortcut for creating ASTs.

```Scala
val evals = ListBuffer[ValDef]()
def precompute(value: Tree, tpe: Type): Ident = {
  val freshName = TermName(c.fresh("eval$"))
  evals += ValDef(Modifiers(), freshName, TypeTree(tpe), value)
  Ident(freshName)
}

val paramsStack = Stack[Tree]((params map (_.tree)): _*)
val refs = s_format.split("(?<=%[\\w%])|(?=%[\\w%])") map {
  case "%d" => precompute(paramsStack.pop, typeOf[Int])
  case "%s" => precompute(paramsStack.pop, typeOf[String])
  case "%%" => Literal(Constant("%"))
  case part => Literal(Constant(part))
}

val stats = evals ++ refs.map(ref => reify(print(c.Expr[Any](ref).splice)).tree)
c.Expr[Unit](Block(stats.toList, Literal(Constant(()))))

```

The snippet below represents a complete definition of the printf macro. To follow the example, create an empty directory and copy the code to a new file named Macros.scala.

```Scala
import scala.reflect.macros.Context
import scala.collection.mutable.{ListBuffer, Stack}

object Macros {
  def printf(format: String, params: Any*): Unit = macro printf_impl

  def printf_impl(c: Context)(format: c.Expr[String], params: c.Expr[Any]*): c.Expr[Unit] = {
    import c.universe._
    val Literal(Constant(s_format: String)) = format.tree

    val evals = ListBuffer[ValDef]()
    def precompute(value: Tree, tpe: Type): Ident = {
      val freshName = TermName(c.fresh("eval$"))
      evals += ValDef(Modifiers(), freshName, TypeTree(tpe), value)
      Ident(freshName)
    }

    val paramsStack = Stack[Tree]((params map (_.tree)): _*)
    val refs = s_format.split("(?<=%[\\w%])|(?=%[\\w%])") map {
      case "%d" => precompute(paramsStack.pop, typeOf[Int])
      case "%s" => precompute(paramsStack.pop, typeOf[String])
      case "%%" => Literal(Constant("%"))
      case part => Literal(Constant(part))
    }

    val stats = evals ++ refs.map(ref => reify(print(c.Expr[Any](ref).splice)).tree)
    c.Expr[Unit](Block(stats.toList, Literal(Constant(()))))
  }
}
```
To use the printf macro, create another file Test.scala in the same directory and put the following code into it. Note that using a macro is as simple as calling a function. It also doesn’t require importing scala.language.experimental.macros.

```Scala
object Test extends App {
  import Macros._
  printf("hello %s!", "world")
}
```
