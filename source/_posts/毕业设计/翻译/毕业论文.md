---
title: 毕业论文
date: 2018/05/21
categories: 毕业论文
tags:
- 毕业论文
---

# 摘要
在互联网飞速发展的当下，编写一款软件已经不再是一个人或者一个公司的事情了，需要人与人之间的分工合作甚至是公司和公司之间的分工合作。因此API文档(接口文档)的地位显得越来越重要。在调研了网上大多数的文档生成工具以后，发现它们都有一个共同的缺点：工程师写完代码后，还需要手动的去维护文档。这不仅仅会增加软件的维护成本，同时也会增软件产生 bug 的风险。本工具尝试使用元编程的技术来解决这个问题。

本工具会制定一系列的接口编写规则，当工程师按照规则把接口代码编写完成时，工具将会在编译时期使用元编程技术来抽取数据，然后自动进行整理、分类最终生成 API 文档，不需要工程师手动的去维护 API 文档。

文章将按照如下的方式进行组织：第二章将会做需求分析和可行性分析，第三章将会介绍本工具的设计思路和用到的技术，第四章将会具体介绍各个模块的实现细节，第五章将会介绍在开发过程中的一些测试样例和最终的效果图展示。
# 1. 绪论
## 1.1 国内状况
在国内，API 文档的使用率非常频繁，在前后端协同开发以及调用别的公司的 API 接口，都需要接口文档来提供开发指导。最近很火的微信小程序开发也是要按照微信官方 API 文档开发的。但是国内好的 API 文档生成工具却寥寥无几。阿里巴巴有一个 API 生成工具的开源项目名为 [RAP](http://rapapi.org/org/index.do)，但是它还是需要工程师写完代码后手动的去维护 API 文档，这依然会产生维护成本和软件bug。
## 1.2 国外状况
在国外，有一个名为 [APIDOC](http://apidocjs.com/#example-basic) 的文档生成工具，它是通过在 API 接口代码中使用注释来标注 API 文档信息，但是它的规则很繁琐，需要标注的信息太多，而且很多信息明明可以从代码中直接抽取。而且维护注释也是需要一定的成本的，这本质上和直接维护文档是一样的。
## 1.3 研究意义
本工具使用元编程技术，对于参数的名称和类型，直接使用元编程技术从代码中抽取；对于参数的描述，使用注解和配置来描述。以这样的方式，不仅仅可以在编译时期自动生成 API 文档，而且维护成本也极低，只要维护配置文件和注解即可。而且本工具是直接抽取代码的信息，这比使用注释标注高明很多，它减少了 API 文档出错的风险。因为注释是不会被编译器检查的，即使写错了编译器也不会报错，但是代码是会被编译器检查的，代码写错，编译自然不通过，程序自然也就运行不起来。
# 2. 需求分析与可行性分析
## 2.1 需求分析
在现代软件开发中，工程师经常会编写接口代码，但是在接口代码编写完成后，还需要手动的编写 API 文档，这会增加软件的维护成本以及软件产生 bug 的几率。因此需要一个可以自动生成 API 文档的工具，工程师可以按照工具制定的规则编写 API 接口，在代码编程完成后，可以自动的生成对应的 API 文档。这样既减少了软件的维护成本，也降低了软件因 API 文档错误而产生 bug 的几率。

这个工具最好可以以第三方扩展库的方式整合到项目工程中，这样既降低了项目的和 API 工具之间的耦合性，也增强了项目本身的可扩展性。
## 2.2 交互流程设计
* 接口代码编写工程师：工程师按照规则把接口代码编写完成时，工具会在编译时期抽取接口代码中的数据，在服务器运行时，配置相关信息，设置一个接口专门负责 API 文档的显示。然后在浏览器里面输入对应的路由，就可以看到自动生成的 API 文档。
* 接口调用工程师：根据链接查看文档，按照文档里面的接口说明，就可以调用需要的接口。
详细的交互流程如下图：
![交互流程图](/image/graduation/interactive.png)

## 2.3 可行性分析
### 2.3.1 市场可行性分析
在互联网飞速发展的当下，经常会存在人与人或者公司与公司之间协同合作开发软件的场景，因此 API 文档成了沟通交流的重要工具，但是现实中，工程师不仅仅需要编写接口代码，而且还需要手动的维护接口文档。因此急需一个 API 文档自动生成工具来帮助工程师减轻工作量，帮助公司减少软件维护成本。
### 2.3.2 技术可行性
在公司实习了几个月，对接口代码的开发模型已经了解的很清楚，对元编程技术已经初步掌握，为了更方便的实现以及在生产中应用此工具，决定基于实习公司是开发模型写一个基于 Play 框架的 API 文档自动生成工具。这样当本地开发测试通过后，可以在实习公司的生产线上部署此工具，可以更好的测试该工具的实际用途以及 bug 的反馈。
# 3. 系统设计
## 3.1 总体设计思路
本工具最终是以第三方內库的形式整合到运行服务器中，但是为了方便测试，还需要模拟一个实际的开发环境。因此本工具分为两部分：
* 工具主体的开发
* 实际开发环境的模拟

### 3.1.1 工具的设计思路
工具的开发是整个设计的核心所在，它需要制定编写接口代码的规则，编译时期的数据解析以及整理和分类。而且它最终需要以第三方內库的形式整合到运行环境，因此，它的最终体现形式是一个 jar 包，也就是被 JVM 编译过的 class 文件。
实际的项目不仅仅会依赖本工具，而且也会依赖很多第三方內库，因此本工具对第三方工具的依赖需要做到越少越好，最好是都不依赖，不然在实际的项目工程中，很容易产生內库冲突。
下图是本工具的目录结构图：
![交互流程图](/image/graduation/play-swa-dir-struct.png)
`build.sbt` 是 SBT 的配置文件，将会在下个小节介绍它。
`play-swagger-api` 是核心的代码所在。
`play-swagger-core` 是一些单元测试的代码。

从总体来看，工具的模块属于后端模块，因为它最终是被引入到后端运行服务器中，用来给前端抽取数据用的。

### 3.1.2 模拟开发环境的设计思路
模拟开发环境不仅仅是用来测试工具的，它的另一个很重要的作用就是作为 API 文档的运行服务器。因此在模拟的开发环境中，不仅仅需要引入编写好的工具包，还要编写相关的 HTML 页面来显示 API 文档。
所以在这个环境中，既需要搭建后端环境，又需要配置前端环境，而且还需要做到前后端分离。后端环境使用 SBT + Scala + Play 来搭建，前端环境使用 Node + Vue 来配置，这样就可以做到前后端分离。
下图是模拟开发环境的目录结构图：
![交互流程图](/image/graduation/play-swa-demo-dir-struct.png)
`client` 是用来存放前端环境的代码和配置。
`server` 是用来存放后端环境的代码和配置。

## 3.2 后端模块设计思路
从整个设计来看，后端的设计包括了工具的设计以及模拟开发环境后端的搭建以及测试接口代码的编写。在描述工具的设计细节之前，先来看看后端使用的一些技术。
### 3.2.1 Scala
Scala 是由德国的计算机科学家和编程方法教授 Martin Odersky 设计出来的，它的设计原理严格遵循数学的逻辑推理。因此它是一门优秀的编程语言，它不仅仅在工业界被广泛使用，在学术界也占用很高的研究地位。它是一门既支持面向对象，又支持函数式编程的语言，如果把面向对象比作是站在平地上观察事物，那么函数式编程则是让你站在楼上观察事物，更好的抽象和认识事物的本质。

而本工具使用 Scala 作为后端语言重要的原因是因为它拥有丰富的类型系统，举个例子，在 Java 中，如果想表示某个变量是可有可无的，在 Java8 之前好像很难去表示，而且还需要使用 `== null` 来判断是否为有值，是一件非常麻烦的事情。但是在 Scala 中，可以使用 `Option[T]` 来表示一个变量的可有可无，而且如果你要使用它，需要使用模式匹配，这样就可以避免存在空指针异常的情况。而且有时候，接口传递过来的参数就是可有可无的，那么使用 `Option` 来接受，是一个非常不错的选择。甚至可以告诉接口调用者，参数类型为 `Option` 类型表示该参数可有可无。

而且 Scala 是基于 JVM 的，拥有很强大的生态系统。所有基于 Java 开发的扩展库，Scala 都可以直接拿过来使用。
### 3.2.2 元编程
编程语言是用来描述(抽象)现实事物的，而用来描述编程语言本身的语言就被称作为元语言，也叫元编程。而元编程也分为两种方式：
* 使用元编程技术抽取编程语言中的数据，例如 Java 反射技术。
* 使用元编程技术自动产生需要的代码，例如 C 语言中的宏替换。

而本工具就需要用到元编程的第一种方式——抽取接口代码的数据。其实接口代码本身也是描述接口功能的一种表现形式，只不过代码的描述存在着弱语义性和不确定性。因此需要制定一些编写接口的规则，通过规则和代码本身的共同描述来确定接口的功能。而元编程技术就是负责用来抽取这些描述信息。

### 3.2.3 Scala 宏
Scala 的宏是元编程的一种实现方式，它拥有很多和编译器进行互操作的接口，它还可以在编译时期抽取接口代码数据。为什么总是要在编译时期抽取数据呢？运行时期不行吗？

因为 Scala 是基于 JVM 的，JVM 有一个设计缺点，就是会在编译时期进行类型擦除，运行时期无法获取类型参数是信息。而本工具的设计思路是使用类型参数来表示请求参数和响应参数的类型，如`SwaAction[A,B]`，`A` 表示请求参数的类型信息，`B` 表示响应参数的类型信息。因此只能在编译时期抽取类型参数的信息。

### 3.2.4 sbt
sbt 是一款基于 Scala 和 Java 的构建工具，和 Java 的 Maven 以及 Ant 功能很相近。可以直接在配置文件里面引入 jar 包的坐标，在项目的启动和编译时期，它会自动去下载对应的 jar 文件。它拥有如下的特色：
* 天生支持对 Scala 的编译并且支持很多 Scala 的测试框架。
* 可以连续的编译，测试以及开发。
* 增量式的测试和编译，只针对那些已经改变或者对测试和重新运行产生影响的文件进行重写编译。
* 构建配置可以使用 Scala 语言来描述，其实本质上是特定领域语言。
* 依赖管理使用 `ivy`(它支持 maven 形式的库)。
* 和 Scala 的解释器整合在一起，可以更快的进行迭代和调试。
* 支持 Java 语言和 Scala 语言混合的工程。

除了上述的特色外，sbt 可以很容易的构建 Scala 工程，只需要输入一行命令即可，而且它还可以很轻易把已有的 Scala 代码构建为一个 jar 文件，并且可以轻易引入其它 sbt 工程。这完美的符合了本工具的开发需求。

### 3.2.5 Play! Framework
Play 是一款基于 Scala 和 Java 的 web 框架，它为 web 应用的开发者准备了很多组件和接口。由于它基于轻量化，无状态以及 web 友好型设计理念，并且基于 Akka 的响应式编程，因此在高并发的情况下，它可以预见性的和极少的消耗系统的资源(CPU,内存和线程)。除此之外，Play 还支持异步编程，类型安全以及数据存储和模型的建立。因此它是一款非常轻量但功能极其强大的 web 框架。而且它可以和 sbt 构建工具进行无缝整合，完全满足本工具的开发和运行需求。

### 3.2.6 ScalaTest
ScalaTest 是一款很优秀的 Scala 测试工具，它可以随着需求而增长，你可以随意使用 ScalaTest 来定位以及测试你的需求。它有如下特色：
* 用法很简单，很容易上手。
* 可以自定义测试用例的代码编写风格。
* 非常适合团队合作，有很强的语义性。
* 让开发者可以更加产品化的去编写代码
* 提供了很多有用的工具来帮助开发者解决bug。

除了上述优点意外，本工具使用它的一个最主要的原因是因为它可以和 sbt 进行无缝整合，可以做到一边开发，一边测试。

## 3.3 前端模块设计思路
本工具前端环境使用 Node + Vue 来搭建，其实本质是还是 HTML + CSS + JS，只不过 Vue 对原始的 HTML + CSS + JS 进行了组件化的封装。下面具体的来介绍它们。
### 3.3.1 HTML
 HTML 全称为超文本标记语言(HyperText Markup Language)，是一种可以被浏览器解析的显示网页内容的语言。HTML元素是构建网站的基石。HTML允许嵌入图像与对象，并且可以用于创建交互式表单，它被用来结构化信息——例如标题、段落和列表等等，也可用来在一定程度上描述文档的外观和语义。HTML的语言形式为尖括号包围的HTML元素（如`<html>`），浏览器使用HTML标签和脚本来诠释网页内容，但不会将它们显示在页面上(引用自维基百科)。

 如果把网页比作一个人，那么 HTML 就是这个人的骨架，它代码的好与坏直接决定了 Web 应用语义性强与弱。开发一个好的 Web 应用，较为重要的一点就是先写好 HTML 代码。
### 3.3.2 CSS
CSS 全称为层叠样式表(Cascading Style Sheets)，一种用来为结构化文档（如HTML文档或XML应用）添加样式（字体、间距和颜色等）的计算机语言(引用自维基百科)。如果把网页比作一个人，那么 CSS 就是它的皮肤，发型，衣装等，一个 Web 应用的优雅程度就是依靠它来进行渲染的。
### 3.3.3 JavaScript
一种可以被浏览器解析的动态的脚本语言，它可以为 Web 应用添加各种行为和动作，例如各种事件的触发。它是一门多范式的编程语言，不仅仅支持面向对象，还支持命令式和函数式的编程范式。
只拥有 HTML + CSS 的 Web 应用其实只是一个植物人，但是如果给它加上 JavaScript，那么他就是一个可以活动的正常人。

### 3.3.4 Node.js
Node.js是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。Node.js由Node.js基金会持有和维护，并与Linux基金会有合作关系。Node.js采用Google开发的V8运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的实时应用程序。

Node.js大部分基本模块都用JavaScript语言编写。在Node.js出现之前，JavaScript通常作为客户端程序设计语言使用，以JavaScript写出的程序常在用户的浏览器上运行。Node.js的出现使JavaScript也能用于服务器端编程。Node.js含有一系列内置模块，使得程序可以脱离Apache HTTP Server或IIS，作为独立服务器运行。(引用自维基百科)
### 3.3.5 Vue.js
Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。
除此之外，Vue 最大的特色之一就是它的组件系统，任何小功能、小模块，都可以把它们抽取为一个个组件，对于那些公用的模块，可以把它们抽取为公共的组件。这样减少了模块与模块的耦合性，使得原本很难维护的前端代码有了很强的模块化，便于维护和扩展。
### 3.3.6 vue-resource
它是一个使用 XMLHttpRequest 或者 JSONP 来发送 web 请求并且处理响应的 Vue 的服务型框架。
它有如下的特色：
* 支持响应式的 API 和 URL 模板。
* 支持对请求和响应的拦截。
* 支持最新的主流浏览器，如火狐，谷歌等。
* 支持 Vue1.0 版本和 Vue2.0 版本
* 很轻量，总共只有 14KB 大小，压缩后只有 5.3KB

本工具使用它来向后台发生 web 请求，获取 API 文档数据。
### 3.3.7 vue-router
vue-router 是 Vue 官方指定的路由，它和 Vue 的源码深度整合，使得单页面应用的开发变得易如反掌。它有如下特色:
* 嵌套的路由/视图表。
* 模块化基于组件的路由配置。
* 提供路由的参数，查询和通配符。
* 基于 Vue.js 过渡系统的视图过渡效果
* 细粒度的导航控制
* 带有自动激活的 CSS class 的链接
* HTML5 历史模式或 hash 模式，在 IE9 中自动降级
* 自定义的滚动条行为

本工具使用它主要是为了更好的单页面开发。
### 3.3.8 ESLint
ESLint 是一款开源的 JavaScript 的代码检查工具最初由 Nicholas C. Zakas 在 2013 年 6 月创建，代码检查是一种静态类型的分析经常被用于查找有问题的模式和不符合特定风格的代码。大多数的编程语言都有代码的检查工具，有时候编译器也会在编译时期进行代码检查。
JavaScript 是一门动态和弱类型的语言，很容易使开发者产生错误。因为没有编译处理的过程，JavaScript 经常使用执行的方式来查找语法上的以及其它类型的错误。而 ESLint 工具会让开发者在不执行 JavaScript 的情况下发现其中的错误。
它有如下的设计哲学：
* 规则的 API 既可以是绑定的，也可以是自定义的。
* 格式化的 API 既可以是绑定的，也可以是自定义的。
* 额外的规则和格式化代码可以被指定在编译时期。
* 规则和格式化代码没有必要去绑定使用。

而本工具的前端使用它主要的原因是它可以检查 JavaScript 代码的错误，规范代码编写的风格。

# 4. 模块实现
在这节中，将会介绍本工具各个模块的具体实现思路，在详细介绍实现思路之前，先来搭建一下开发环境。
## 4.1 开发环境的搭建和配置
Scala 是基于 JVM 的，因此在正式搭建环境之前，需要先安装 Java，Scala，sbt等基础的软件。由于本工具的开发环境是 Ubuntu(Linux) 环境，因此有些软件可以直接使用 Ubuntu 内置的 APT 包管理工具直接安装即可。

JDK 安装：JDK 建议安装1.8 版本，首先去 Oracle 官网上下载 JDK 1.8 的工具包，然后解压到任意目录。最后需要配置环境变量，在 Linux 中配置环境变量很简单，只要在 `etc/profile` 中进行如下配置即可：

```Java
#Java environment
JAVA_HOME=jdk工具包存储路径
PATH=$JAVA_HOME/bin:$PATH
CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export JAVA_HOME
export PATH
export CLASSPATH
```
保存后，可以通过 `java -version` 来查询是否安装成功：
![](/image/graduation/java-version.png)

Scala 安装：直接使用 `sudo apt-get install scala` 安装 Scala，可以通过 `scala -version` 来查询是否安装成功：
![](/image/graduation/scala-version.png)

sbt 安装：直接使用 `sudo apt-get install sbt` 安装 sbt，通过输入 `sbt -h` 发现显示如下信息即为安装成功:
![](/image/graduation/sbt-h.png)

完成了基础的软件安装后，接下来进行后端环境的搭建。
### 4.1.1 搭建后端环境
通过上面的描述，后端需要搭建两个工程环境，它们分别是：
* 工具的开发环境
* 工具的演示环境

#### 4.1.1.1 工具开发环境的搭建——play-swagger
sbt 对新手提供了很多直接可以使用的模板工程，因此直接使用 `sbt new scala/hello-world.g8` 来创建一个简单的模板工程，并且设置工程的目录名称为 `play-swa`
![](/image/graduation/play-swagger-template.png)
然后进入 `play-swa` 目录，在命令行输入 `sbt`，即可进入 sbt 的控制台，当然在这之前，需要修改此目录下的 `build.sbt` 文件的配置，来符合本工具的设计需求：
```Scala
name              := "play-swagger" // 工程名称
organization      := "dripcom.swagger" // 组织
version           := "0.2-SNAPSHOT" // 工程版本号
scalaVersion      := "2.12.4"       // Scala 版本号
publishMavenStyle := true
```
在 sbt 控制台中，你可以输入 `compile` 命令来编译整个工程，输入 `clean` 命令来清除所有已经编译的结果，输入 `update` 命令来更新引入的扩展库，输入 `run` + 端口号来启动服务器，输入 `test:compile` 来编译测试用例的代码，输入`test` 来运行所有的测试用例，当然你也可以使用 `testOnly` 来指定你想要运行的某个的测试用例。

你现在不需要完整的知道这些命令怎么用，只要对它们有个印象即可，后面会详细的介绍它们的使用。
![](/image/graduation/sbt-command-demo.png)

由于使用 Scala 宏技术，宏的编译要求单独的一个线程，因此需要把测试代码和宏代码使用不同的线程进行编译，在 sbt 中，可以把宏的代码单独的放入一个目录内，然后以一个 jar 包的形式引入到测试代码中。

因此在上面已经搭建好的 `play-swa` 工程的根目录下，需要新建两个目录，`play-swagger-api` 和 `play-swagger-core` 分别用于存储宏代码和测试代码。而且还要让`play-swagger-core` 依赖 `play-swagger-api`。除此之外， `play-swagger-core` 因为需要测试的原因，还需要引入和 `play!`、`Akka` 相关的第三方工具包。上面的描述需要在 `build.sbt` 文件者进行配置，下面给出了部分配置文件的代码，完整的代码可以参考附录部分。
```Scala
// 在整个工程中引入 play-swagger-api 和 play-swagger-core
lazy val root =
  project
    .in(file("."))
    .aggregate(
      `play-swagger-api`, // 宏的代码
      `play-swagger-core` // 测试用例的代码
    )

// 设置 play-swagger-api 目录，并引入相关依赖
lazy val `play-swagger-api` = project
  .in(file("play-swagger-api"))
  .settings(commonSettings: _*)

// 设计 play-swagger-api 目录，并且引入相关 play 和 akka 的依赖
lazy val `play-swagger-core` = project
  .in(file("play-swagger-core"))
  .dependsOn(`play-swagger-api` % "compile->compile;test->test") //引入上面的 play-swagger-api 的包
.settings(
    libraryDependencies ++= Seq(
      "com.typesafe.play" %% "play"           % playVersion,
      "com.typesafe.akka" %% "akka-http-core" % akkaHttpVersion
    ) ++ akkaDeps
)
```
当配置完成，在 `play-swagger`工程的根目录下输入`sbt` 命令进入 sbt 控制台，输入`compile` 命令，sbt 将会自动的创建目录和进行依赖。

#### 4.1.1.2 工具演示环境的搭建——play-swagger-demo
工具的演示环境是基于 Play! 框架的后端服务，因此可以到[Play官网](https://www.playframework.com/download#starters)去下载一个最普通的用例包，然后解压，把 `build.sbt` 配置文件中项目名称修改为`play-swagger-demo`,并且引入上面编写的的 `play-swagger-api` 工具包。`play-swagger-demo` 的 `build.sbt` 文件配置信息如下：
```Scala
name := """play-swagger-demo"""

version := "1.0-SNAPSHOT"

lazy val root = (project in file(".")).enablePlugins(PlayScala)

resolvers += Resolver.sonatypeRepo("snapshots")

scalaVersion := "2.12.4"

crossScalaVersions := Seq("2.11.12", "2.12.4")

libraryDependencies += guice

libraryDependencies += "play-swagger-api" %% "play-swagger-api" % "0.1.0-SNAPSHOT" // 引入之前的 play-swagger-api 工具包
```

配置完成后，就可以进入 sbt 的控制台，进行一系列的开发和测试操作，如果想运行服务器，在控制台中输入`run` 即可，默认端口号为 `9000`，当然你也可以使用 `run` + 端口号来指定端口。

### 4.1.2 搭建前端环境
前端环境使用的是 Node.js 和 Vue
#### 4.1.2.1 安装 Node.js、 npm 以及 vue
因为本工具使用的是 Ubuntu 作为开发环境，因此很多工具直接使用 Ubuntu 自带的 APT 包管理器直接安装即可。
Node.js 的安装：直接使用 `sudo apt-get install nodejs` 命令安装即可。

npm 的安装：直接使用 `sudo apt-get install npm`命令安装。

Vue 的安装：直接使用 `npm install vue` 命令安装。

vue-cli 的安装：直接使用 `npm install -g vue-cli` 命令安装

可以使用 `-v` 参数来检查是否安装成功。
![](/image/graduation/node-npm-vue.png)

现在，已经安装好前端开发需要的软件工具，下面开始来搭建一个 Vue 的开发环境。
#### 4.1.2.2 Vue 开发环境的搭建
使用 `vue init webpack client` 来构建一个名称为 `client` 的前端环境，运行的时候会给你很多选项，敲回车键默认即可。
![](/image/graduation/vue-init.png)

进入 `clinet` 目录，运行 `npm install` 命令安装相关依赖即可。
![](/image/graduation/vue-install.png)

此时，还需要安装 vue-resource，因此使用 `npm install vue-resource`命令安装即可。
![](/image/graduation/vue-resource.png)

此时，前端环境已经搭建完成，可以在 `clinet` 的根目录下使用`npm run dev` 命令启动该工程，然后在浏览器的地址栏里面输入：localhost:8080 即可看到效果。
### 4.1.3 Git 版本控制
为了做好版本控制和防止代码的丢失，需要为 `play-swagger` 和 `play-swagger-demo` 添加版本控制，这里本工具使用 Git 来作为版本控制的工具。使用 `sudo apt-get install git` 安装 Git ，然后可以使用下面的命令进行一些基础的操作：
新建仓库：使用 `git init` 命令。
添加内容：使用 `git add xxx` 命令。
提交内容：使用 `git commit -m xxx` 命令。
推送到远程的 github 仓库： `git push origin master` 命令。
详细的 Git 的安装和操作可以参考[廖雪峰 Git 教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)

到此，工程需要的各种软件和环境都已经搭建完成，下面来介绍各个模块的具体实现细节，首先来看一下后端模块实现的各个细节。
## 4.2 后端实现
后端模块包括全部的 `play-swagger` 工程和 `play-swagger-demo` 工程的后端部分。但是`play-swagger` 工程是后端模块的核心，先来看一下它的实现细节。
### 4.2.1 接口规则的制定
本文中一直提到工程师需要按照工具制定的规则编写接口，那么规则到底是什么呢？是如何制定的呢？
#### 4.2.1.1 基于 Play! 的 Action 增强
因为本工具是基于 Play! 框架的，因此在设计的本工具的时候，需要遵循 Play! 框架的设计原则。在 Play! 框架中，每一个请求都是一个 `Action`，而 `Action` 的本质其实是一个 `Request[A] => Result` 的函数，说白了就是请求到响应结果的一个函数。在上文中曾经提到本工具的设计思路是根据类型参数来绑定请求参数和响应参数，在这里，Play! 框架已经实现了一个类型参数 `A`——请求参数，为了实现这个设计思想，需要增强 Play! 原生的 `Action`，这里使用继承的思想，定义一个 `SwaAction[A,R] extends Action[A]`，这样，就可以用 `A` 来表示请求参数，`R` 来表示响应参数。

在网络的 HTTP 请求中，最常用的请求方法是 POST 和 GET，而在 API 文档中需要给出请求方式，因此为了在解析规则的时候更好的区分请求的方式，需进一步的明确 `Action` 的类型。使用 `PostSwaAction[A,R] extends SwaAction[A,R]` 来标识为 POST 请求方式，使用 ` GetSwaAction[A,R] extends SwaAction[A,R]` 来表示 GET 请求方式。

到此，本工具已经完了请求方式的规则制定，但是原始的 Play! 返回的 `Action[A]`，那如何让 Play! 返回本工具需要的`SwaAction[A, R]` 呢？
#### 4.2.1.2 基于 Play! 的 async 增强
在实际是开发中，Play! 的异步请求是性能最好也是被使用最多的请求方式，为了可以让 Play! 返回 `SwaAction[A, R]`，需增强 `async` 方法。这里使用装饰者模式来增强 Play! 原始的 `ActionBuilder`，重新定义一个 `SwaActionBuilder`，并且在里面引入 Play! 原始的 `ActionBuilder`，利用原始的 `ActionBuilder` 来执行一些 Play! 原生的操作，但是最终的返回值类型封装为 `SwaAction[A,R]` 类型。模型代码如下：

```Scala
class SwaActionBuilder[Req[_], A] private(
  builder: ActionBuilder[Req, A]) { // 引入原始的 ActionBuilder

  def async[A1, Res](_parser: BodyParser[A1])(body : Req[A1] => Future[Res])(
    implicit _writeable: Writeable[Res],
    _ec: ExecutionContext): SwaAction[A1, Res] = new SwaAction[A1, Res] { // 返回 SwaAction[A, R] 类型
    def executionContext = _ec
    def parser = _parser
    def apply(request: Request[A1]) = { // 利用 ActionBuiler 处理原生的 Play! 操作
      builder.apply(parser).invokeBlock(request, (ra: Req[A1]) => body(ra).map(Results.Ok(_)))
    }
  }
}
```
关于返回 `PostSwaAction[A, R]` 和 `GetSwaAction[A, R]` 的 `async` 代码可以参考附录的代码部分。到此本文已经完成了在 Play! 原生的 `Action[A]` 和本工具需求的 `SwaAction[A, R]` 之间搭建了一座桥梁，制定了请求方式的规则，但工程师如何描述接口本身呢？

#### 4.2.1.3 接口描述规则制定
上文中曾经提过，在 Play! 中一个 `Action` 代表一个接口请求。那么描述接口其实就是在描述 `Action`，可以定义一个注解，让注解作用在 `Action` 上面，注解的信息即为接口的描述信息。定义注解的代码如下：
```Scala
final class ActionAnnotation(
    // 描述Action
    descrip: String
) extends Annotation
```

使用注解的代码如下：
```Scala
 // Action 注解的使用
  @ActionAnnotation(descrip="测试 POST 请求")
  /**
   *  定义一个 Post 请求
   */
  def examplePostAction: PostSwaAction [PersonGet, Person] = Swa.asyncPost[PersonGet,Person](parse.json[PersonGet]) { req =>
    val personGet = req.body
    Future.successful(Person(personGet.id, "foo", 1))
  }
```
#### 4.2.1.4 接口参数的规则制定
对于接口描述，除了上面的信息外，还需要对请求参数和响应参数进行描述，在上文中已经提到使用 `SwaAction[A, R]`中的 `A` 表示请求参数，`B` 表示响应参数，因此只需要描述 `A` 类型和 `B` 类型中的属性即可。
描述属性方式有很多种，这里给出了两种描述方式：
* 配置规则
配置规则使用的是配置文件的方式来描述类中的属性信息，但是由于不同的接口可以使用同一种类型作为请求或者响应的参数，为了便于区分，在使用配置文件描述的时候，需要加上接口的路径和方法名称作为唯一的标识符。
例如：`DemoController.examplePostAction.PersonGet.id = 人的id`

* 注解规则
使用注解来描述类型参数的属性是一种非常简单和方便的做法，需要先定义一个描述属性的注解，代码如下：
```Scala
/**
 * 参数是注解，作用于参数的 case class 字段
 */
final class FieldAnnotation(
  descrip: String
) extends Annotation
```
   使用此注解的模板代码：
```Scala
case class PersonGet(
  @(FieldAnnotation @meta.getter)("人的ID")
    id: Long
```
   可以发现使用注解非常的方便和直观。

### 4.2.2 规则的解析
如果把规则的制定比作为一种正向的运算，那么规则的解析就可以理解为一种逆向的运算，只不过这种运算是在编译时期完成的。下面就来看看如何使用宏在编译时期解析规则。

### 4.2.3 数据的整理和保存
### 4.2.4 路由的自动生成

## 4.2 前端实现
### 4.2.1 UI 设计
### 4.2.2 前端数据解析和显示

# 5. 测试并运行

## 5.1 后端单元测试
### 5.1.1 API 数据抽取测试
### 5.1.2 配置读取测试
### 5.1.3 注解读取测试
### 5.1.4 路由生成测试

## 5.2 前端交互测试

## 5.3 运行和展示
### 5.3.1 运行环境配置
### 5.3.2 效果图展示

# 6. 总结与展望

# 7. 致谢

# 8 参考文献

# 9 附录
