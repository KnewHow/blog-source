---
title: 毕业论文
date: 2018/05/21
categories: 毕业论文
tags:
- 毕业论文
---

# 摘要
在互联网飞速发展的当下，编写一款软件已经不再是一个人或者一个公司的事情了，需要人与人之间的分工合作甚至是公司和公司之间的分工合作。因此API文档(接口文档)的地位显得越来越重要。在调研了网上大多数的文档生成工具以后，发现它们都有一个共同的缺点：工程师写完代码后，还需要手动的去维护文档。这不仅仅会增加软件的维护成本，同时也会增软件产生 bug 的风险。本工具尝试使用元编程的技术来解决这个问题。

本工具会制定一系列的接口编写规则，当工程师按照规则把接口代码编写完成时，工具将会在编译时期使用元编程技术来抽取数据，然后自动进行整理、分类最终生成 API 文档，不需要工程师手动的去维护 API 文档。

文章将按照如下的方式进行组织：第二章将会做需求分析和可行性分析，第三章将会介绍本工具的设计思路和用到的技术，第四章将会具体介绍各个模块的实现细节，第五章将会介绍在开发过程中的一些测试样例和最终的效果图展示。
# 1. 绪论
## 1.1 国内状况
在国内，API 文档的使用率非常频繁，在前后端协同开发以及调用别的公司的 API 接口，都需要接口文档来提供开发指导。最近很火的微信小程序开发也是要按照微信官方 API 文档开发的。但是国内好的 API 文档生成工具却寥寥无几。阿里巴巴有一个 API 生成工具的开源项目名为 [RAP](http://rapapi.org/org/index.do)，但是它还是需要工程师写完代码后手动的去维护 API 文档，这依然会产生维护成本和软件bug。
## 1.2 国外状况
在国外，有一个名为 [APIDOC](http://apidocjs.com/#example-basic) 的文档生成工具，它是通过在 API 接口代码中使用注释来标注 API 文档信息，但是它的规则很繁琐，需要标注的信息太多，而且很多信息明明可以从代码中直接抽取。而且维护注释也是需要一定的成本的，这本质上和直接维护文档是一样的。
## 1.3 研究意义
本工具使用元编程技术，对于参数的名称和类型，直接使用元编程技术从代码中抽取；对于参数的描述，使用注解和配置来描述。以这样的方式，不仅仅可以在编译时期自动生成 API 文档，而且维护成本也极低，只要维护配置文件和注解即可。而且本工具是直接抽取代码的信息，这比使用注释标注高明很多，它减少了 API 文档出错的风险。因为注释是不会被编译器检查的，即使写错了编译器也不会报错，但是代码是会被编译器检查的，代码写错，编译自然不通过，程序自然也就运行不起来。
# 2. 需求分析与可行性分析
## 2.1 需求分析
在现代软件开发中，工程师经常会编写接口代码，但是在接口代码编写完成后，还需要手动的编写 API 文档，这会增加软件的维护成本以及软件产生 bug 的几率。因此需要一个可以自动生成 API 文档的工具，工程师可以按照工具制定的规则编写 API 接口，在代码编程完成后，可以自动的生成对应的 API 文档。这样既减少了软件的维护成本，也降低了软件因 API 文档错误而产生 bug 的几率。

这个工具最好可以以第三方扩展库的方式整合到项目工程中，这样既降低了项目的和 API 工具之间的耦合性，也增强了项目本身的可扩展性。
## 2.2 交互流程设计
* 接口代码编写工程师：工程师按照规则把接口代码编写完成时，工具会在编译时期抽取接口代码中的数据，在服务器运行时，配置相关信息，设置一个接口专门负责 API 文档的显示。然后在浏览器里面输入对应的路由，就可以看到自动生成的 API 文档。
* 接口调用工程师：根据链接查看文档，按照文档里面的接口说明，就可以调用需要的接口。
详细的交互流程如下图：
![交互流程图](/image/graduation/interactive.png)

## 2.3 可行性分析
### 2.3.1 市场可行性分析
在互联网飞速发展的当下，经常会存在人与人或者公司与公司之间协同合作开发软件的场景，因此 API 文档成了沟通交流的重要工具，但是现实中，工程师不仅仅需要编写接口代码，而且还需要手动的维护接口文档。因此急需一个 API 文档自动生成工具来帮助工程师减轻工作量，帮助公司减少软件维护成本。
### 2.3.2 技术可行性
在公司实习了几个月，对接口代码的开发模型已经了解的很清楚，对元编程技术已经初步掌握，为了更方便的实现以及在生产中应用此工具，决定基于实习公司是开发模型写一个基于 Play 框架的 API 文档自动生成工具。这样当本地开发测试通过后，可以在实习公司的生产线上部署此工具，可以更好的测试该工具的实际用途以及 bug 的反馈。
# 3. 系统设计
## 3.1 总体设计思路
本工具最终是以第三方內库的形式整合到运行服务器中，但是为了方便测试，还需要模拟一个实际的开发环境。因此本工具分为两部分：
* 工具主体的开发
* 实际开发环境的模拟

### 3.1.1 工具的设计思路
工具的开发是整个设计的核心所在，它需要制定编写接口代码的规则，编译时期的数据解析以及整理和分类。而且它最终需要以第三方內库的形式整合到运行环境，因此，它的最终体现形式是一个 jar 包，也就是被 JVM 编译过的 class 文件。
实际的项目不仅仅会依赖本工具，而且也会依赖很多第三方內库，因此本工具对第三方工具的依赖需要做到越少越好，最好是都不依赖，不然在实际的项目工程中，很容易产生內库冲突。
下图是本工具的目录结构图：
![交互流程图](/image/graduation/play-swa-dir-struct.png)
`build.sbt` 是 SBT 的配置文件，将会在下个小节介绍它。
`play-swagger-api` 是核心的代码所在。
`play-swagger-core` 是一些单元测试的代码。

从总体来看，工具的模块属于后端模块，因为它最终是被引入到后端运行服务器中，用来给前端抽取数据用的。

### 3.1.2 模拟开发环境的设计思路
模拟开发环境不仅仅是用来测试工具的，它的另一个很重要的作用就是作为 API 文档的运行服务器。因此在模拟的开发环境中，不仅仅需要引入编写好的工具包，还要编写相关的 HTML 页面来显示 API 文档。
所以在这个环境中，既需要搭建后端环境，又需要配置前端环境，而且还需要做到前后端分离。后端环境使用 SBT + Scala + Play 来搭建，前端环境使用 Node + Vue 来配置，这样就可以做到前后端分离。
下图是模拟开发环境的目录结构图：
![交互流程图](/image/graduation/play-swa-demo-dir-struct.png)
`client` 是用来存放前端环境的代码和配置。
`server` 是用来存放后端环境的代码和配置。

## 3.2 后端模块设计思路
从整个设计来看，后端的设计包括了工具的设计以及模拟开发环境后端的搭建以及测试接口代码的编写。在描述工具的设计细节之前，先来看看后端使用的一些技术。
### 3.2.1 Scala
Scala 是由德国的计算机科学家和编程方法教授 Martin Odersky 设计出来的，它的设计原理严格遵循数学的逻辑推理。因此它是一门优秀的编程语言，它不仅仅在工业界被广泛使用，在学术界也占用很高的研究地位。它是一门既支持面向对象，又支持函数式编程的语言，如果把面向对象比作是站在平地上观察事物，那么函数式编程则是让你站在楼上观察事物，更好的抽象和认识事物的本质。

而本工具使用 Scala 作为后端语言重要的原因是因为它拥有丰富的类型系统，举个例子，在 Java 中，如果想表示某个变量是可有可无的，在 Java8 之前好像很难去表示，而且还需要使用 `== null` 来判断是否为有值，是一件非常麻烦的事情。但是在 Scala 中，可以使用 `Option[T]` 来表示一个变量的可有可无，而且如果你要使用它，需要使用模式匹配，这样就可以避免存在空指针异常的情况。而且有时候，接口传递过来的参数就是可有可无的，那么使用 `Option` 来接受，是一个非常不错的选择。甚至可以告诉接口调用者，参数类型为 `Option` 类型表示该参数可有可无。

而且 Scala 是基于 JVM 的，拥有很强大的生态系统。所有基于 Java 开发的扩展库，Scala 都可以直接拿过来使用。
### 3.2.2 元编程
编程语言是用来描述(抽象)现实事物的，而用来描述编程语言本身的语言就被称作为元语言，也叫元编程。而元编程也分为两种方式：
* 使用元编程技术抽取编程语言中的数据，例如 Java 反射技术。
* 使用元编程技术自动产生需要的代码，例如 C 语言中的宏替换。

而本工具就需要用到元编程的第一种方式——抽取接口代码的数据。其实接口代码本身也是描述接口功能的一种表现形式，只不过代码的描述存在着弱语义性和不确定性。因此需要制定一些编写接口的规则，通过规则和代码本身的共同描述来确定接口的功能。而元编程技术就是负责用来抽取这些描述信息。

### 3.2.3 Scala 宏
Scala 的宏是元编程的一种实现方式，它拥有很多和编译器进行互操作的接口，它还可以在编译时期抽取接口代码数据。为什么总是要在编译时期抽取数据呢？运行时期不行吗？

因为 Scala 是基于 JVM 的，JVM 有一个设计缺点，就是会在编译时期进行类型擦除，运行时期无法获取类型参数是信息。而本工具的设计思路是使用类型参数来表示请求参数和响应参数的类型，如`SwaAction[A,B]`，`A` 表示请求参数的类型信息，`B` 表示响应参数的类型信息。因此只能在编译时期抽取类型参数的信息。

### 3.2.4 sbt
sbt 是一款基于 Scala 和 Java 的构建工具，和 Java 的 Maven 以及 Ant 功能很相近。可以直接在配置文件里面引入 jar 包的坐标，在项目的启动和编译时期，它会自动去下载对应的 jar 文件。它拥有如下的特色：
* 天生支持对 Scala 的编译并且支持很多 Scala 的测试框架。
* 可以连续的编译，测试以及开发。
* 增量式的测试和编译，只针对那些已经改变或者对测试和重新运行产生影响的文件进行重写编译。
* 构建配置可以使用 Scala 语言来描述，其实本质上是特定领域语言。
* 依赖管理使用 `ivy`(它支持 maven 形式的库)。
* 和 Scala 的解释器整合在一起，可以更快的进行迭代和调试。
* 支持 Java 语言和 Scala 语言混合的工程。

除了上述的特色外，sbt 可以很容易的构建 Scala 工程，只需要输入一行命令即可，而且它还可以很轻易把已有的 Scala 代码构建为一个 jar 文件，并且可以轻易引入其它 sbt 工程。这完美的符合了本工具的开发需求。

### 3.2.5 Play! Framework
Play 是一款基于 Scala 和 Java 的 web 框架，它为 web 应用的开发者准备了很多组件和接口。由于它基于轻量化，无状态以及 web 友好型设计理念，并且基于 Akka 的响应式编程，因此在高并发的情况下，它可以预见性的和极少的消耗系统的资源(CPU，内存和线程)。除此之外，Play 还支持异步编程，类型安全以及数据存储和模型的建立。因此它是一款非常轻量但功能极其强大的 web 框架。而且它可以和 sbt 构建工具进行无缝整合，完全满足本工具的开发和运行需求。

### 3.2.6 ScalaTest
ScalaTest 是一款很优秀的 Scala 测试工具，它可以随着需求而增长，你可以随意使用 ScalaTest 来定位以及测试你的需求。它有如下特色：
* 用法很简单，很容易上手。
* 可以自定义测试用例的代码编写风格。
* 非常适合团队合作，有很强的语义性。
* 让开发者可以更加产品化的去编写代码
* 提供了很多有用的工具来帮助开发者解决bug。

除了上述优点意外，本工具使用它的一个最主要的原因是因为它可以和 sbt 进行无缝整合，可以做到一边开发，一边测试。

## 3.3 前端模块设计思路
本工具前端环境使用 Node + Vue 来搭建，其实本质是还是 HTML + CSS + JS，只不过 Vue 对原始的 HTML + CSS + JS 进行了组件化的封装。下面具体的来介绍它们。
### 3.3.1 HTML
 HTML 全称为超文本标记语言(HyperText Markup Language)，是一种可以被浏览器解析的显示网页内容的语言。HTML元素是构建网站的基石。HTML允许嵌入图像与对象，并且可以用于创建交互式表单，它被用来结构化信息——例如标题、段落和列表等等，也可用来在一定程度上描述文档的外观和语义。HTML的语言形式为尖括号包围的HTML元素（如`<html>`），浏览器使用HTML标签和脚本来诠释网页内容，但不会将它们显示在页面上(引用自维基百科)。

 如果把网页比作一个人，那么 HTML 就是这个人的骨架，它代码的好与坏直接决定了 Web 应用语义性强与弱。开发一个好的 Web 应用，较为重要的一点就是先写好 HTML 代码。
### 3.3.2 CSS
CSS 全称为层叠样式表(Cascading Style Sheets)，一种用来为结构化文档（如HTML文档或XML应用）添加样式（字体、间距和颜色等）的计算机语言(引用自维基百科)。如果把网页比作一个人，那么 CSS 就是它的皮肤，发型，衣装等，一个 Web 应用的优雅程度就是依靠它来进行渲染的。
### 3.3.3 JavaScript
一种可以被浏览器解析的动态的脚本语言，它可以为 Web 应用添加各种行为和动作，例如各种事件的触发。它是一门多范式的编程语言，不仅仅支持面向对象，还支持命令式和函数式的编程范式。
只拥有 HTML + CSS 的 Web 应用其实只是一个植物人，但是如果给它加上 JavaScript，那么他就是一个可以活动的正常人。

### 3.3.4 Node.js
Node.js是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。Node.js由Node.js基金会持有和维护，并与Linux基金会有合作关系。Node.js采用Google开发的V8运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的实时应用程序。

Node.js大部分基本模块都用JavaScript语言编写。在Node.js出现之前，JavaScript通常作为客户端程序设计语言使用，以JavaScript写出的程序常在用户的浏览器上运行。Node.js的出现使JavaScript也能用于服务器端编程。Node.js含有一系列内置模块，使得程序可以脱离Apache HTTP Server或IIS，作为独立服务器运行。(引用自维基百科)
### 3.3.5 Vue.js
Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。
除此之外，Vue 最大的特色之一就是它的组件系统，任何小功能、小模块，都可以把它们抽取为一个个组件，对于那些公用的模块，可以把它们抽取为公共的组件。这样减少了模块与模块的耦合性，使得原本很难维护的前端代码有了很强的模块化，便于维护和扩展。
### 3.3.6 vue-resource
它是一个使用 XMLHttpRequest 或者 JSONP 来发送 web 请求并且处理响应的 Vue 的服务型框架。
它有如下的特色：
* 支持响应式的 API 和 URL 模板。
* 支持对请求和响应的拦截。
* 支持最新的主流浏览器，如火狐，谷歌等。
* 支持 Vue1.0 版本和 Vue2.0 版本
* 很轻量，总共只有 14KB 大小，压缩后只有 5.3KB

本工具使用它来向后台发生 web 请求，获取 API 文档数据。
### 3.3.7 vue-router
vue-router 是 Vue 官方指定的路由，它和 Vue 的源码深度整合，使得单页面应用的开发变得易如反掌。它有如下特色:
* 嵌套的路由/视图表。
* 模块化基于组件的路由配置。
* 提供路由的参数，查询和通配符。
* 基于 Vue.js 过渡系统的视图过渡效果
* 细粒度的导航控制
* 带有自动激活的 CSS class 的链接
* HTML5 历史模式或 hash 模式，在 IE9 中自动降级
* 自定义的滚动条行为

本工具使用它主要是为了更好的单页面开发。
### 3.3.8 ESLint
ESLint 是一款开源的 JavaScript 的代码检查工具最初由 Nicholas C. Zakas 在 2013 年 6 月创建，代码检查是一种静态类型的分析经常被用于查找有问题的模式和不符合特定风格的代码。大多数的编程语言都有代码的检查工具，有时候编译器也会在编译时期进行代码检查。
JavaScript 是一门动态和弱类型的语言，很容易使开发者产生错误。因为没有编译处理的过程，JavaScript 经常使用执行的方式来查找语法上的以及其它类型的错误。而 ESLint 工具会让开发者在不执行 JavaScript 的情况下发现其中的错误。
它有如下的设计哲学：
* 规则的 API 既可以是绑定的，也可以是自定义的。
* 格式化的 API 既可以是绑定的，也可以是自定义的。
* 额外的规则和格式化代码可以被指定在编译时期。
* 规则和格式化代码没有必要去绑定使用。

而本工具的前端使用它主要的原因是它可以检查 JavaScript 代码的错误，规范代码编写的风格。

# 4. 模块实现
在这节中，将会介绍本工具各个模块的具体实现思路，在详细介绍实现思路之前，先来搭建一下开发环境。
## 4.1 开发环境的搭建和配置
Scala 是基于 JVM 的，因此在正式搭建环境之前，需要先安装 Java，Scala，sbt等基础的软件。由于本工具的开发环境是 Ubuntu(Linux) 环境，因此有些软件可以直接使用 Ubuntu 内置的 APT 包管理工具直接安装即可。

JDK 安装：JDK 建议安装1.8 版本，首先去 Oracle 官网上下载 JDK 1.8 的工具包，然后解压到任意目录。最后需要配置环境变量，在 Linux 中配置环境变量很简单，只要在 `etc/profile` 中进行如下配置即可：

```Java
#Java environment
JAVA_HOME=jdk工具包存储路径
PATH=$JAVA_HOME/bin:$PATH
CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export JAVA_HOME
export PATH
export CLASSPATH
```
保存后，可以通过 `java -version` 来查询是否安装成功：
![](/image/graduation/java-version.png)

Scala 安装：直接使用 `sudo apt-get install scala` 安装 Scala，可以通过 `scala -version` 来查询是否安装成功：
![](/image/graduation/scala-version.png)

sbt 安装：直接使用 `sudo apt-get install sbt` 安装 sbt，通过输入 `sbt -h` 发现显示如下信息即为安装成功:
![](/image/graduation/sbt-h.png)

完成了基础的软件安装后，接下来进行后端环境的搭建。
### 4.1.1 搭建后端环境
通过上面的描述，后端需要搭建两个工程环境，它们分别是：
* 工具的开发环境
* 工具的演示环境

#### 4.1.1.1 工具开发环境的搭建——play-swagger
sbt 对新手提供了很多直接可以使用的模板工程，因此直接使用 `sbt new scala/hello-world.g8` 来创建一个简单的模板工程，并且设置工程的目录名称为 `play-swa`
![](/image/graduation/play-swagger-template.png)
然后进入 `play-swa` 目录，在命令行输入 `sbt`，即可进入 sbt 的控制台，当然在这之前，需要修改此目录下的 `build.sbt` 文件的配置，来符合本工具的设计需求：
```Scala
name              := "play-swagger" // 工程名称
organization      := "dripcom.swagger" // 组织
version           := "0.2-SNAPSHOT" // 工程版本号
scalaVersion      := "2.12.4"       // Scala 版本号
publishMavenStyle := true
```
在 sbt 控制台中，你可以输入 `compile` 命令来编译整个工程，输入 `clean` 命令来清除所有已经编译的结果，输入 `update` 命令来更新引入的扩展库，输入 `run` + 端口号来启动服务器，输入 `test:compile` 来编译测试用例的代码，输入`test` 来运行所有的测试用例，当然你也可以使用 `testOnly` 来指定你想要运行的某个的测试用例。

你现在不需要完整的知道这些命令怎么用，只要对它们有个印象即可，后面会详细的介绍它们的使用。
![](/image/graduation/sbt-command-demo.png)

由于使用 Scala 宏技术，宏的编译要求单独的一个线程，因此需要把测试代码和宏代码使用不同的线程进行编译，在 sbt 中，可以把宏的代码单独的放入一个目录内，然后以一个 jar 包的形式引入到测试代码中。

因此在上面已经搭建好的 `play-swa` 工程的根目录下，需要新建两个目录，`play-swagger-api` 和 `play-swagger-core` 分别用于存储宏代码和测试代码。而且还要让`play-swagger-core` 依赖 `play-swagger-api`。除此之外， `play-swagger-core` 因为需要测试的原因，还需要引入和 `play!`、`Akka` 相关的第三方工具包。上面的描述需要在 `build.sbt` 文件者进行配置，下面给出了部分配置文件的代码，完整的代码可以参考附录部分。
```Scala
// 在整个工程中引入 play-swagger-api 和 play-swagger-core
lazy val root =
  project
    .in(file("."))
    .aggregate(
      `play-swagger-api`, // 宏的代码
      `play-swagger-core` // 测试用例的代码
    )

// 设置 play-swagger-api 目录，并引入相关依赖
lazy val `play-swagger-api` = project
  .in(file("play-swagger-api"))
  .settings(commonSettings: _*)

// 设计 play-swagger-api 目录，并且引入相关 play 和 akka 的依赖
lazy val `play-swagger-core` = project
  .in(file("play-swagger-core"))
  .dependsOn(`play-swagger-api` % "compile->compile;test->test") //引入上面的 play-swagger-api 的包
.settings(
    libraryDependencies ++= Seq(
      "com.typesafe.play" %% "play"           % playVersion,
      "com.typesafe.akka" %% "akka-http-core" % akkaHttpVersion
    ) ++ akkaDeps
)
```
当配置完成，在 `play-swagger`工程的根目录下输入`sbt` 命令进入 sbt 控制台，输入`compile` 命令，sbt 将会自动的创建目录和进行依赖。

#### 4.1.1.2 工具演示环境的搭建——play-swagger-demo
工具的演示环境是基于 Play! 框架的后端服务，因此可以到[Play官网](https://www.playframework.com/download#starters)去下载一个最普通的用例包，然后解压，把 `build.sbt` 配置文件中项目名称修改为`play-swagger-demo`，并且引入上面编写的的 `play-swagger-api` 工具包。`play-swagger-demo` 的 `build.sbt` 文件配置信息如下：
```Scala
name := """play-swagger-demo"""

version := "1.0-SNAPSHOT"

lazy val root = (project in file(".")).enablePlugins(PlayScala)

resolvers += Resolver.sonatypeRepo("snapshots")

scalaVersion := "2.12.4"

crossScalaVersions := Seq("2.11.12", "2.12.4")

libraryDependencies += guice

libraryDependencies += "play-swagger-api" %% "play-swagger-api" % "0.1.0-SNAPSHOT" // 引入之前的 play-swagger-api 工具包
```

配置完成后，就可以进入 sbt 的控制台，进行一系列的开发和测试操作，如果想运行服务器，在控制台中输入`run` 即可，默认端口号为 `9000`，当然你也可以使用 `run` + 端口号来指定端口。

### 4.1.2 搭建前端环境
前端环境使用的是 Node.js 和 Vue
#### 4.1.2.1 安装 Node.js、 npm 以及 vue
因为本工具使用的是 Ubuntu 作为开发环境，因此很多工具直接使用 Ubuntu 自带的 APT 包管理器直接安装即可。
Node.js 的安装：直接使用 `sudo apt-get install nodejs` 命令安装即可。

npm 的安装：直接使用 `sudo apt-get install npm`命令安装。

Vue 的安装：直接使用 `npm install vue` 命令安装。

vue-cli 的安装：直接使用 `npm install -g vue-cli` 命令安装

可以使用 `-v` 参数来检查是否安装成功。
![](/image/graduation/node-npm-vue.png)

现在，已经安装好前端开发需要的软件工具，下面开始来搭建一个 Vue 的开发环境。
#### 4.1.2.2 Vue 开发环境的搭建
使用 `vue init webpack client` 来构建一个名称为 `client` 的前端环境，运行的时候会给你很多选项，敲回车键默认即可。
![](/image/graduation/vue-init.png)

进入 `clinet` 目录，运行 `npm install` 命令安装相关依赖即可。
![](/image/graduation/vue-install.png)

此时，还需要安装 vue-resource，因此使用 `npm install vue-resource`命令安装即可。
![](/image/graduation/vue-resource.png)

此时，前端环境已经搭建完成，可以在 `clinet` 的根目录下使用`npm run dev` 命令启动该工程，然后在浏览器的地址栏里面输入：localhost:8080 即可看到效果。
### 4.1.3 Git 版本控制
为了做好版本控制和防止代码的丢失，需要为 `play-swagger` 和 `play-swagger-demo` 添加版本控制，这里本工具使用 Git 来作为版本控制的工具。使用 `sudo apt-get install git` 安装 Git ，然后可以使用下面的命令进行一些基础的操作：
新建仓库：使用 `git init` 命令。
添加内容：使用 `git add xxx` 命令。
提交内容：使用 `git commit -m xxx` 命令。
推送到远程的 github 仓库： `git push origin master` 命令。
详细的 Git 的安装和操作可以参考[廖雪峰 Git 教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)

到此，工程需要的各种软件和环境都已经搭建完成，下面来介绍各个模块的具体实现细节，首先来看一下后端模块实现的各个细节。
## 4.2 后端实现
后端模块包括全部的 `play-swagger` 工程和 `play-swagger-demo` 工程的后端部分。但是`play-swagger` 工程是后端模块的核心，先来看一下它的实现细节。
### 4.2.1 接口规则的制定
本文中一直提到工程师需要按照工具制定的规则编写接口，那么规则到底是什么呢？是如何制定的呢？
#### 4.2.1.1 基于 Play! 的 Action 增强
因为本工具是基于 Play! 框架的，因此在设计的本工具的时候，需要遵循 Play! 框架的设计原则。在 Play! 框架中，每一个请求都是一个 `Action`，而 `Action` 的本质其实是一个 `Request[A] => Result` 的函数，说白了就是请求到响应结果的一个函数。在上文中曾经提到本工具的设计思路是根据类型参数来绑定请求参数和响应参数，在这里，Play! 框架已经实现了一个类型参数 `A`——请求参数，为了实现这个设计思想，需要增强 Play! 原生的 `Action`，这里使用继承的思想，定义一个 `SwaAction[A,R] extends Action[A]`，这样，就可以用 `A` 来表示请求参数，`R` 来表示响应参数。

在网络的 HTTP 请求中，最常用的请求方法是 POST 和 GET，而在 API 文档中需要给出请求方式，因此为了在解析规则的时候更好的区分请求的方式，需进一步的明确 `Action` 的类型。使用 `PostSwaAction[A,R] extends SwaAction[A,R]` 来标识为 POST 请求方式，使用 ` GetSwaAction[A,R] extends SwaAction[A,R]` 来表示 GET 请求方式。

到此，本工具已经完了请求方式的规则制定，但是原始的 Play! 返回的 `Action[A]`，那如何让 Play! 返回本工具需要的`SwaAction[A, R]` 呢？
#### 4.2.1.2 基于 Play! 的 async 增强
在实际是开发中，Play! 的异步请求是性能最好也是被使用最多的请求方式，为了可以让 Play! 返回 `SwaAction[A, R]`，需增强 `async` 方法。这里使用装饰者模式来增强 Play! 原始的 `ActionBuilder`，重新定义一个 `SwaActionBuilder`，并且在里面引入 Play! 原始的 `ActionBuilder`，利用原始的 `ActionBuilder` 来执行一些 Play! 原生的操作，但是最终的返回值类型封装为 `SwaAction[A,R]` 类型。模型代码如下：

```Scala
class SwaActionBuilder[Req[_], A] private(
  builder: ActionBuilder[Req, A]) { // 引入原始的 ActionBuilder

  def async[A1, Res](_parser: BodyParser[A1])(body : Req[A1] => Future[Res])(
    implicit _writeable: Writeable[Res],
    _ec: ExecutionContext): SwaAction[A1, Res] = new SwaAction[A1, Res] { // 返回 SwaAction[A, R] 类型
    def executionContext = _ec
    def parser = _parser
    def apply(request: Request[A1]) = { // 利用 ActionBuiler 处理原生的 Play! 操作
      builder.apply(parser).invokeBlock(request, (ra: Req[A1]) => body(ra).map(Results.Ok(_)))
    }
  }
}
```
关于返回 `PostSwaAction[A, R]` 和 `GetSwaAction[A, R]` 的 `async` 代码可以参考附录的代码部分。到此本文已经完成了在 Play! 原生的 `Action[A]` 和本工具需求的 `SwaAction[A, R]` 之间搭建了一座桥梁，制定了请求方式的规则，但工程师如何描述接口本身呢？

#### 4.2.1.3 接口描述规则制定
上文中曾经提过，在 Play! 中一个 `Action` 代表一个接口请求。那么描述接口其实就是在描述 `Action`，可以定义一个注解，让注解作用在 `Action` 上面，注解的信息即为接口的描述信息。定义注解的代码如下：
```Scala
final class ActionAnnotation(
    // 描述Action
    descrip: String
) extends Annotation
```

使用注解的代码如下：
```Scala
 // Action 注解的使用
  @ActionAnnotation(descrip="测试 POST 请求")
  /**
   *  定义一个 Post 请求
   */
  def examplePostAction: PostSwaAction [PersonGet, Person] = Swa.asyncPost[PersonGet,Person](parse.json[PersonGet]) { req =>
    val personGet = req.body
    Future.successful(Person(personGet.id, "foo", 1))
  }
```
#### 4.2.1.4 接口参数的规则制定
对于接口描述，除了上面的信息外，还需要对请求参数和响应参数进行描述，在上文中已经提到使用 `SwaAction[A, R]`中的 `A` 表示请求参数，`B` 表示响应参数，因此只需要描述 `A` 类型和 `B` 类型中的属性即可。
描述属性方式有很多种，这里给出了两种描述方式：
* 配置规则
配置规则使用的是配置文件的方式来描述类中的属性信息，但是由于不同的接口可以使用同一种类型作为请求或者响应的参数，为了便于区分，在使用配置文件描述的时候，需要加上接口的路径和方法名称作为唯一的标识符。
例如：`DemoController.examplePostAction.PersonGet.id = 人的id`

* 注解规则
使用注解来描述类型参数的属性是一种非常简单和方便的做法，需要先定义一个描述属性的注解，代码如下：
```Scala
/**
 * 参数是注解，作用于参数的 case class 字段
 */
final class FieldAnnotation(
  descrip: String
) extends Annotation
```
   使用此注解的模板代码：
```Scala
case class PersonGet(
  @(FieldAnnotation @meta.getter)("人的ID")
    id: Long
```
   可以发现使用注解非常的方便和直观。

### 4.2.2 规则的解析
如果把规则的制定比作为一种正向的运算，那么规则的解析就可以理解为一种逆向的运算，只不过这种运算是在编译时期完成的。下面就来看看如何使用宏在编译时期解析规则。
#### 4.2.2.1 宏的定义和实现
本工具抽取 API 文档的数据的核心方法使用的是 Scala 的宏技术，Scala 的宏是一种在编译时期可以抽取代码数据和产生需要的模板代码的技术，它需要按照如下的规则来使用：
* 定义宏
定义宏和定义普通函数的声明是一样，它们都可以有参数和参数的类型，而且可以带有类型参数。只不过宏的函数体需要使用 `macro` 关键字来声明这是一个宏，而且在 `macro` 关键字后面紧接着需要跟着一个宏实现，并且需要引入`scala.language.experimental.macros`， 模板代码如下：
```Scala
 //定义宏
def assert(cond: Boolean, msg: Any) =
     //宏实现
    macro Macros.impl
```
* 实现宏
实现宏需要重新构建一个类，并且需要引入 `scala.reflect.macros.blackbox._`，而且还需要在类的构造函数里面引入`
scala.reflect.macros.blackbox.Context` 对象，这个对象非常重要，后续所有的数据提取都需要依靠他来完成。因为宏实现函数在编译时期被调用，因此函数的参数已经不是正常意义上类型，它们都是抽象语法树，因此不能使用常规意义的 `Int`，`Double` 来描述它们，需要使用 `c.Expr[Int]` 来表示正常的`Int` 类型，其它类型以此类推，如果宏实现函数带有类型参数 `T`，那么需要使用 `T: c.WeakTypeTag` 来声明。返回值也需要使用 `c.Expr[Type]` 来声明，当然使用类型推到也是一个不错的选择。下面是一个宏实现函数的例子：
```Scala
//构造函数中引入 context 对象
class Macros(val c: Context) {
  import c.universe._

  //宏实现函数，C 表示类型参数
  def impl(cond: c.Expr[Boolean], msg: c.Expr[Any]) : c.Expr[Unit] = {
    c.Expr[Unit](q"""println("Hello World")""")
  }
}
```

* 使用宏
使用宏很简单，就和调用普通的函数一样，直接调用宏定义函数，而且返回值也可以被正常的操作。下面是一个使用宏的模板代码：
```Scala
  val r = assert(true,"hello macro")
  println(s"result -> ${r}")
```

到此，本文已经介绍了如何定义、实现以及使用宏，下面将会介绍如何定义以及实现可以完成 API 文档数据抽取的宏。

#### 4.2.2.2 定义抽取 API 文档数据的宏
在实际开发业务的过程在，一般都是一个大的分类下面有很多的子分类，例如在图书模块下面，可以有表示图书本身的BookApi，也可以有表示图书借阅情况的BookBorrowApi。这样的安排是非常合理的，代码的可读取很高，而且后期也很容易扩展。由此本设计的思路就是以单个 controller  对象为最小单位，针对每个 controller 来抽取它里面所有的接口。然后把这些 controller 进行整理分类，最终完成所有 API 文档数据的抽取。

由于在编译时期抽取信息，这里的 controller 是不能进行实例化的，因此需要把 controller 以类型参数的方式传递进去，然后抽取它每个 action 方法上面的注解信息(接口描述)以及返回值类型(`SwaAction[A, R]`)，通过返回值类型来进一步抽取请求参数信息和响应参数信息。最终的返回结果应该是一个 `List` 的 JSON 字符串，里面有每个接口的描述信息(Action)。
因此需要一个带有类型参数和返回值为 `List[String]` 的宏定义，宏实现需要按照上文所描述去编写。
宏定义的模板代码如下：
```Scala
object PlaySwagger {
  //定义宏
  def playApi[C]():List[String] =
    //宏实现
    macro Macros.api[C]
}
```

宏实现的模板代码如下：
```Scala
class Macros(val c: Context) {
  import c.universe._

  //宏实现函数，C 表示类型参数
  def api[C: c.WeakTypeTag]() = {
    val apis  = extractApis(controller.toString, ms)
    q"$apis"
  }
}
```
到此，满足本工具需求的宏定义和宏实现已经介绍完毕了，那么本工具如何抽取这个 controller 中所有的 action 方法呢？

#### 4.2.2.3 方法过滤
在上文中，使用 `C: c.WeakTypeTag` 来表示某个 controller 的类型，但是这个只是类型的声明，想要获取真正的 controller 类型，需要调用 Scala 宏的接口方法，使用 `weakTypeTag[C].tpe`  接口方法来获取 controller 的真实的类型。它的返回值是一个 `Universe.Type` 类型。进一步，本工具需要获取这个类型中的所有返回值为 `SwaAction[A, R]`方法，对于返回值不是这个类型的，需要过滤掉，最终需要的结果是一个 `List[MethodSymbol]` 结果集。因此本工具的过滤代码如下：
```Scala
 val ms = weakTypeTag[C].tpe.decls.collect {
      case m: MethodSymbol if !m.isConstructor && isSwaAction(m)  => { // 把构造函数和不是 SwaAction 返回值的方法过滤掉
        m
      }
}.toList  // 把最终的结果转换为一个包含所有方法的 List 集合
```
到此本文已经介绍如何获取需要的所有的接口方法(Action)方法，剩下工作就是遍历这个 `List[MethodSymbol]` 集合，对每个接口进行数据解析。
#### 4.2.2.4 请求方式规则解析
在上文的描述在，本工具是根据 Action 方法的返回值来确定请求的方式，如果返回值类型为 `PostSwaAction` 就是 POST 请求，如果为 `GetSwaAction` 就为 GET 请求，此时，本文已经获取到表示每个 Action 方法的类型——`MethodSymbol`， 因此只需要调用 `m(MethodSymbol).returnType` 获取返回值类型，然后进行判断即可。
#### 4.2.2.5 接口描述信息规则解析
在上文的接口规则制定的描述中，接口的描述使用的是 `ActionAnnotation` 注解的方式进行描述，因此解析的方式很简单，只有获取 `MethodSymbol` 上的注解即可。直接使用 Scala 宏提供的接口方法 ` m(MethodSymbol).annotations` 来获取 Action 方法上的注解信息，然后进行处理、返回即可。

#### 4.2.2.6 接口参数规则的解析
在上文的描述中，接口的参数类型是接口返回值的类型参数，也就是`SwaAction[A,R]` 中的 `A` 和 `R`，在上文中，已经介绍了如何获取返回值类型，这里在进一步，需要获取返回值的类型参数，这也很简单，直接使用 Scala 宏的` val typeParams = m(MethodSymbol).returnType.typeArgs` 方法来获取返回值的类型参数，返回值是一个数组类型的 `c.universe.Type`，因为一个类型可能有很多的类型参数。幸运的是，这里可以很明确的知道数组中只有两个元素，第一个元素 `typeParams(0)` 表示的 `A`——请求参数类型，第二个元素表示`typeParams(1)` 表示的 `R`——响应的类型参数。剩下的工作就是抽取这两个类型中所有属性的名称、属性的类型、以及属性的描述。

抽取属性名称和属性类型很简单，直接使用 `t(c.universe.Type).members.collect` 获取所有的成员，这里返回的其实是 `List[MethodSymbol]` 类型，然后获取方法的名称和返回值类型即可。对于属性的描述，上文中介绍了两种描述，分别是配置文件和注解的方式。
针对配置文件的方式，需要用`类名称.方法名称.类型名称.属性名称`作为 key来读取配置文件的方式进行获取。
针对注解的方式，可以参考上文中使用 `m(methodSymbol).annotations` 来直接获取。
到这里可以看出，使用注解不论是从规则制定还是规则解析，都是一种非常方便和直观的方法。

接口参数的最终的返回值类型是一个 `Map[String,Map[String,String]]` 类型，外面的 Map 以参数的名称为 key，参数的类型和描述为value(Map)，对于值的 Map，分别以 type 和 describe 为 key，参数的类型和描述为值。
如下面的参数将会生成 `Map(id -> Map(type -> Int, describe -> 人的ID))`

```Scala
case class PersonGet(
  @(FieldAnnotation @meta.getter)("人的ID")
    id: Long
```
上面规则解析的详细代码可以参数附录部分。
### 4.2.3 路由的自动生成
到此，本文已经完整的介绍了请求方式的数据抽取，接口描述的数据抽取和接口参数的数据抽取，但是似乎还忘记了一个重要信息的抽取——接口路由的抽取。在 API 文档中，还有一个非常重要的数据，就是接口请求的 URL，也成为路由，它决定了你应该使用什么样的路由来请求接口，也是接口请求的唯一标识。在 Play! 框架中，接口的路由是配置在 `/conf/routes` 文件中的，但是这种配置的方式会给本工具的设计产生麻烦，因为在抽取接口信息后，还需要去读取路由的配置文件。而且不同的模块可能会有自己独立的配置文件，这会导致需要读取很多份配置文件，代码的可维护性很差。

因此，本工具决定放弃这种配置路由的方式，在编译时期直接为每个接口自动的生成路由，这样的设计方案其实是合理的，因为在配置路由的时候，其实就是在指定是哪个类的哪个方法，而这些数据完全可以使用 Scala 宏来获取。而且路由的本身其实和类名称以及接口方法名称是相关的，它是都是具备语义化的。而且 Play! 框架本身也是支持自动生成路由的，它提供了很多路由自定义的接口。通过上面的分析，本工具使用自动生成路由的设计方案是合理的，也是可行的。

因此本工具还需要定义另外一个宏以及它的实现来实现路由的自动生成，由于 Play! 框架本身在自定义路由的时候提供了 controller 的实例，因此在设计这个宏的时候，不仅仅需要传递 controller 的类型，而且也需要传递 controller 的实例。而且这个宏最终的返回值类型是一个以路由为 key，`Action` 为值的 Map 集合。但是由于 `Action` 类型在 jar 包并不存在，因此需使用 `HNil => Any` 来表示 `Action` 类型。在需要 `Action` 的时候，使用模式匹配进行转换。
具体的代码见附录

### 4.2.4 数据的整理和保存
到此，本文已经介绍完接口数据的抽取，但是它们只是众多 API 接口中的一个，它们是零散的，因此本工具需要对这些零散的接口进行分类和整理。一般工程中，都是一个主模块下面分为很多的子模块，而目前的接口数据抽取的宏只能针对单独的子模块，因此在最终显示 API 文档前，需要对模块进行分组和划分。

#### 4.2.4.1 宏返回的数据格式
上文曾介绍宏返回的结果集实际上是一个`List[String]`，更进一步，其实是 JSON 格式的数组，如下图所示：
![](/image/graduation/macro-data-structure.png)
里面有请求方式的描述 `method`，接口本身的描述 `describe`，路由的描述 `route` 以及请求参数的描述`req` 和响应参数的描述 `res`。这里有两组数据，分别对应着对应着`查询图书接口` 和 `添加图书接口`。

#### 4.2.4.2 子模块数据的封装
上面的数据只有对每个接口具体的描述，并没有关于这个子模块的描述，因此，需要使用 JSON 进一步进行封装，把子模块的名称引入。下图为封装子模块名称后的数据结构图：
![](/image/graduation/suber-model-data-structure.png)
其中 `book` 表示子模块的名称，这里使用的是英文，中文也是可以的。 `book` 对象的值其实就是上文中的 JSON 数组，这里做了一层封装，为了前端更好的解析和显示子模块的名称。

#### 4.2.4.3 父模块数据的封装
在实际的工程中，一个父模块下面有很多子模块，因此还需要再次对 JSON 对象进行封装，引入父模块的名称，数据结构如下图：
![](/image/graduation/super-model-data-structure.png)
这里最外层的`book` 表示父模块的名称，里面的 `book` 和 `bookBorrow` 表示子模块的 JSON 对象。

#### 4.2.4.4 整个工程所有父模块数据的封装
在整个工程中，有很多的父模块，因此在上文的基础上，需要进一步封装：
![](/image/graduation/whole-project-data-structure.png)
整体的数据结构是一个 JSON 格式的数组，其中 `book`，`score`，`居民信息接口` 是数组中的元素，表示整个工程下面的主模块，而主模块下面又有很多子模块对象。
到此本文已经完成了对工程中所有接口数据的封装和整理，下图为整体的数据结构模型图：
![](/image/graduation/data-category.png)
数据整理和分类的具体代码可以参数文章的附录部分。


## 4.2 前端实现
到此，本工具已经完成了接口数据的解析和抽取，并且已经做好了整个工程的 API 文档数据的整理和分类，下面需要前端对这些数据进行解析、渲染和显示。这里属于前端模块，而且是实际工程的前端模块，实际工程必须需要要提供前端页面用来显示 API 文档。
### 4.2.1 UI 设计
对于文档显示的 UI 界面，本工具的设计理念为侧栏 + 主栏。侧栏用于显示模块的目录，最多可以显示三级目录，它们分别是主模块名称，子模块名称以及子模块下面每个接口的名称。主栏用于显示具体的接口信息。
### 4.2.2 前端数据解析和显示
数据的解析主要使用 JS 代码来完成数据的解析，由于本工具是使用 Vue 框架，它是一款响应式的前端框架，只要用户做出改变，就会重新调用数据解析函数对数据进行解析。

首先前端需要使用 `vue-resource` 向后台服务器发生接口请求，本工具开发环境的请求路径为`http://localhost:9000/apis`，返回的数据为上文中所描述的 JSON 格式的数组。然后需要按照上文中所给的数据格式进行层层解析，最终把解析到的数据按照一定的次序和逻辑进行渲染和显示即可。数据解析的代码可以参阅附录部分。
# 5. 测试并运行
测试是软件开发过程中一个必不可少的环节，从最小的单元测试到项目整体的测试，每一项测试的结果和数据都是至关重要的，它决定了当前设计方案的是否合理以及是否可以继续下一个模块的开发。
## 5.1 后端单元测试
后端部分本工具主要使用单元测试，开发完每个子模块后，使用单元测试运行一下测试用例，如果满足本工具的设计要求就进行下一步的开发，否则重新设计实现思路。本工具使用的单元测试工具是 scalatest，它的优点在前面已经介绍过了，下面就来看看如何使用它进行单元测试。
### 5.1.1 API 数据抽取测试
在运行测试用例之前，需要先编写一个测试用例，测试抽取 API 数据的测试代码如下：
```Scala
package test.com.dripower.play.swa

import org. scalatest._
import demo._

class DemoApiSpec extends FlatSpec {
  "test obtain DemoApi API document data" should "suceess" in {
    val a = DemoController.getApi
    println(s"api -> ${a}")
    assert(true)
  }
}
```
然后需要在 sbt 控制台输入 `testOnly test.com.dripower.play.swa.DemoApiSpec` 运行该测试用例即可，测试的结果如下：
![](/image/graduation/test-api-result.png)
通过测试的结果可以看出已经完全获取了接口所需要的所有描述信息，因此本设计方案是合理的，可以继续进行下一个模块的开发。
### 5.1.2 自动路由生成测试
自动路由测试的本质是可以获取某个类中的某个方法，然后在其它地方直接可以调用，虽然在 `play-swa` 的 jar 包不能运行服务器，但是可以进行场景模拟，只要获取某个类中的某个方法，然后可以在某个地方调用它即可，测试用例代码如下：
```Scala
class RouteSpec extends FlatSpec {
  "A route macro" should "success" in {
    val c = new DemoController
    val m = PlaySwagger.routes[DemoController](c)
    var lamda = m.get("test-DemoController-demoAction")
    println(s"lamda -> ${lamda}")
    lamda match {
      case Some(r) => r(HNil)
      case _ => println("the method is not exsit")
    }
    assert(true)
  }
}

class DemoController {
  def demoAction = {
    println(s"lala -> ")
  }
}

```
在 sbt 控制台使用 `testOnly play.swagger.test.RouteSpec` 运行测试用例，结果如下图所示：
![](/image/graduation/route-test-result.png)
通过测试结果可以看出已经可以在其它地方调用 `DemoController` 的 `demoAction` 方法了，本设计思路是合理而且是可行的。
## 5.3 运行和展示
到此，本工具已经完了所有的开发以及单元测试，那么剩下的工作就是搭建运行环境和效果的展现。
### 5.3.1 运行环境配置
首先我们需要把开发好的 `play-swagger` 工具包构建为一个 jar 包，在 `play-swagger` 的 sbt 控制台中，使用 `publishLocal` 即可完成本地打包，在`play-swagger-demo` 工程的 build.sbt 文件中使用 `libraryDependencies += "play-swagger-api" %% "play-swagger-api" % "0.1.0-SNAPSHOT"` 即可引入。
然后在在`play-swagger-demo` 工程是 sbt 控制台中依次执行 `update`，`clean`，`compile`，`run` 即可运行服务器。
启动服务器的效果图如下：
![](/image/graduation/server-run.png)
### 5.3.2 效果图展示
服务器启动完毕后，在浏览器地址栏输入 `http://localhost:8080` 即可显示 API 文档，效果图如下图所示：
![](/image/graduation/api-doc-show.png)
可以看出，API 文档完整的显示了整个工程的接口结构，请求方式，路由，以及请求参数和响应参数。
为了测试接口的信息是否正确，可以使用向服务器发送测试请求，请求的结构如下图所示：
![](/image/graduation/test-request-result.png)
通过测试结果可以发现，使用文档给出的信息发送请求，可以获取与文档一致的返回结果，因此本工具的设计是合理而且成功的。

# 6. 总结与展望
通过本次设计，让我明白设计一款软件不是一件很容易的事情，需要大量的知识积累。而且在写代码之前，一定要先想好设计方案，如果没有设计方案就胡乱的写代码，就可能会导致因设计方案的错误而代码白写，造成大量的时间和精力的浪费。

此工具目前虽然可以完整的显示 API 文档信息，但有些地方的配置还略显繁琐，而且有的地方还有一些小的 bug。我希望等我完成学业后可以在公司实际的项目中使用它，进一步完善和改进这个工具。
# 7. 致谢
大学四年一晃就过，首先我得感谢这四年里给予我帮助的同学和老师，没有他们的帮助，现在的我可能没有这么优秀。其次我还要感谢实习公司的小伙伴们，他们在工具设计的技术方面给了我很大的支持和帮助。最后，我还要感谢答辩老师和毕业设计指导老师，他们在开题报告和论文书写方面给了我很多帮助。谢谢你们，感谢一路上有你们的帮助。
# 8 参考文献
[1]Cay S. Horstmann.快学Scala 电子工业出版社，2017
[2]Paul Chiusano（保罗·基乌萨诺），[美] Rúnar Bjarnason（诺曼·比亚尔纳松） 著；王宏江 译 .Scala函数式编程 .电子工业出版社，2016
[3]Baron Schwartz，Peter Zaitsev，Vadim Tkachenko 著；宁海元，周振兴，彭立勋 等 译.高性能MySQL（第3版） 电子工业出版社，2013
[4] [美] 弗里曼（Adam Freeman） 著；谢廷晟，牛化成，刘美英 译.HTML5权威指南.人民邮电出版社，2014
[5] 迈耶（Eric A. Meyer） 著；尹志忠，侯妍 译 CSS权威指南（第3版）.中国电力出版社，2008
[6] Douglas Crockford（道格拉斯·克罗克福德） 著；赵泽欣 等.JavaScript语言精粹（修订版）.电子工业出版社,2012
[7] Nicholas C. Zakas（尼古拉斯·泽卡斯） 著；丁琛 译.高性能JavaScript 电子工业出版社，2015
[8] （美）Thomas H.Cormen，Charles E.Leiserson，Ronald L.Rivest，Clifford Stein 著；殷建平，徐云，王刚 等译.算法导论（原书第3版）.机械工业出版社，2012
[9] Randal，E.，Bryant Computer System 机械工业出版社，2017
[10] [美] James，F.，Kurose 等 著 Computer Networking:A Top-Down Approach Sixth Edition.机械工业出版社，2012
[11] Martin Odersky ,Lex Spoon,Bill Venners.Programming in Scala.Artima Inc，2014
[12] 洋，贺亚茹 著.MySQL数据库应用从入门到精通.中国铁道出版社，2016
[13] [美] Nicholas C. Zakas 著；李晶，郭凯，张散集 译.编写可维护的JavaScript.人民邮电出版社，2013年
[14] [美] Bruce Eckel.Thinking in Java.Prentice Hall,2012
[15] Javey. S. “CONCEPT OF 'CORRESPONDENCE' IN JSP”,Proceedings of the Hawaii International Conference on System Science，Vol2,1987
[16] MIKE LEE. HTML5 Comes To Fruition MIKE LEE[J]《Information Week》, 2008
# 9 附录
