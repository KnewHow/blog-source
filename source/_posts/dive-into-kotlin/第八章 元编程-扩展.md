---
title: 元编程
date: 2018/07/01
categories: 编程语言
author: Jilen, How
tags:
- Kotlin
---

# 第八章 元编程
在之前学习Java的时候，Java的反射是一个比较难而且重要的知识点。但是在很多框架和工具类的中，你都能见到Java反射的影子，而且很多问题使用反射解决会更加方便。但是本章会告诉你Java的反射只是元编程的一种方式，元编程的威力要比反射更加强大。本章我们将会以元编程作为开篇，然后介绍元编程在Kotlin中是如何使用的。最后我们会介绍Kotlin的注解，并使用元编程来解析我们自己定义的注解。

在正式讨论元编程之前，我们先来看一个将data class转换成Map的例子。这个需求非常常见，相信大部分程序员都编写过类似的数据转换代码。

```kotlin
data class User(val name: String, val age: Int)

object User {
  fun toMap(a: User): Map<String, Any> = {
    hashMapOf("name" to name, "age" to age)
  }
}
```

实现非常简单,对任何一个稍有经验的程序员都不构成任何难度，但是要完美实现这个需求却需要考虑更多，上述方案就有一个缺点：
每一个新的类型我们都需要重复实现toMap函数，因为每个类型拥有不同属性。

这显然是一种不好的实践，它有两个问题:

+ 违背了DRY(Don't Repeat Yourself)原则。这些实现虽然代码不完全一样，但是结构十分雷同，在data class数量变得非常多情况下，会出现大量类似的样板代码。
+ 很容易将属性名写错。所有属性名都需要人工编写，很难保证100%正确，在data class多的情况下，这个问题变得更加严重。

>DRY的原则是“系统中的每一部分，都必须有一个单一的、明确的、权威的代表”，指的是（由人编写而非机器生成的）代码和测试所构成的系统，必须能够表达所应表达的内容，但是不能含有任何重复代码。当DRY原则被成功应用时，一个系统中任何单个元素的修改都不需要与其逻辑无关的其他元素发生改变。此外，与之逻辑上相关的其他元素的变化均为可预见的、均匀的，并如此保持同步。(维基百科)

当然，相信很多读者已经开始思考如何用反射来实现这个函数了。


## 8.1 程序和数据

我们先用反射来实现一下这个函数，由于所有类型只需要一个函数，
所以我们可以定义全局的`Mapper`对象来完成这个需求。

```kotlin
object Mapper {
   fun <A : Any> toMap(a: A) = {
        // 获取A中所有的属性
        a::class.memberProperties.map { m ->
            val p = m as KProperty
            p.name to p.call(a)
        }.toMap()
    }
}
Mapp.toMap(new User("humora", 17))
```

利用反射我们完美实现了需求：

+ 能适用于所有data class。只需要调用一个`Mapper.toMap`函数我们就能将所以类型转化成Map。
+ 不再需要手工创建`Map`。所有的属性名都是自动根据`KClass`对象获取的，不存在写错的可能。


现在我们来审视一下上述代码中的`a::class`。`a::class`的类型是`KClass`，是Kotlin中描述类型的类型（通常被称为metaclass）。如果我们将`User`看成是描述现实概念的数据结构，那么在传入参数类型为`User`时`a::class`则可以看成描述`User`类型的数据，这样描述数据的数据就可以称之为元数据。那么元数据究竟和我们说**元编程**有何关联呢？




### 8.1.1 什么是元编程

前面已经提到描述数据的数据可以称之为元素据。我们将程序看成是描述需求的数据，那么描述程序的数据就是程序的元数据。如前文例子中的`a::class`就是描述传入类型`A`的元数据。而像这样操作元数据的编程就可以称之为元编程。
很多人可能会抱怨：说了这么多，元编程不就是反射吗？
这个说法是不全面的，元编程可以用下面一句话概括。

> 程序即是数据，数据即是程序。

注意这句话包含两个方面意思:

+ 前半句指的是访问描述程序的数据，如我们通过反射获取类型信息。
+ 后半句则是指将这些数据转化成对应的程序，也就是所谓代码生成。

反射就是获取描述程序信息的典型例子，相信大部分读者已经十分熟悉了，我们不再赘述其概念。而代码生成则相对陌生一些，先来看一个简单的例子(来自维基百科)。

```bash
#!/bin/sh
# metaprogram
echo '#!/bin/sh' > program
for i in $(seq 992)
do
    echo "echo $i" >> program
done
chmod +x program
```

这个脚本创建了一个名为`program`的文件，并通过`echo`命令将代码写入该文件。这就是一个典型的生成代码的例子，这个例子将程序作为程序的输出。

看到这里大家应该对元编程的概念有了基本了解。这是一个非常简单的概念，不需要理解什么深奥的数学公式也能掌握。
仔细思考之后不难发现，元编程就像高阶函数一样，是一种更高阶的抽象，高阶函数将函数作为输入或输出，而元编程则是将程序本身作为输入或输出。

同时我们也会思考，元数据经过操作之后能不能直接作为程序使用？也就“程序即数据，数据即程序”这句话中前后的数据是否指的是同一种数据？
这个问题不同语言有不同答案，Kotlin中我们显然没法将一个KClass修改之后将其反过来生成一个新的class来使用；但是在Lisp中，一切都可以视为LinkedList，而Lisp的宏则允许直接将这些LinkedList作为程序的一部分。
像Lisp这样的一致性，我们称之为同像性（homoiconicity）。
>在计算机编程中，同像性（homoiconicity，来自希腊语单词 homo，意为与符号含义表示相同）是某些编程语言的特殊属性，它意味着一个程序的结构与其句法是相似的，因此易于通过阅读程序来推测程序的内在涵义。如果一门编程语言具备了同像性，说明该语言的文本表示（通常指源代码）与其抽象语法树（AST）具有相同的结构（即，AST 和语法是同形的）。该特性允许使用相同的表示语法，将语言中的所有代码当成资料，来存取以及转换，提供了“代码即数据”的理论前提。(维基百科)

总结一下目前我们得到的信息：

+ 元编程是指操作元数据的编程。他通常需要获取程序本身的信息或者直接生成程序的一部分或者两者兼而有之。
+ 元编程可以消除某些样板代码。如前文例子那样原本需要对每个类型编写特定转化代码，而现在只需要统一的一个函数即可实现。

然而元编程不是只有优点，同样也存在不少缺点：

+ 首先它有一定的学习成本，在没听说过相关的技术之前，程序员们通常会感觉到摸不着头脑。
+ 它编写的代码不够直接，需要进一步思考才能被理解。

前面例子中，在不使用反射情况下，代码非常直接；而用了反射之后，你必须对Kotlin的reflection api有所了解才能阅读。这还是比较简单的情况，一些支持宏的编程语言，这些代码将会变得更加难以理解。所以在工程实践中，我们推崇Least Power原则，即使用最初级的、最简单的能满足你需求的技术，而不能单纯为了炫耀而采用某些高级的特性或技术。


### 8.1.2 常见的元编程技术

理解了元编程的概念之后，我们继续讨论元编程技术常见的实现手段。目前主流的实现方式包括：

+ 运行时通过`API`暴露程序信息，我们多次提及的反射就是这种实现思路。
+ 动态执行代码。多见于脚本语言，如JavaScript就有eval函数，可以动态将文本作为代码执行。
+ 通过外部程序实现目的。如编译器，在将源文件解析为AST之后可以针对这些AST做各种转化。这种实现思路最典型的例子是我们常常谈论的语法糖，编译器会将这部分代码AST转化为相应的等价的AST，这个过程通常被称为desuger。

以上便是常见的实现思路，我们看看这些思路在编程语言中的体现：

+ 8.1.2.1 反射

这是读者们最熟悉的技术，但是可能大部分读者没想过反射这个词的确切含义。
反射：有时候也称为自反，是指元语言（即前文提到的描述程序的数据结构）和要描述的语言是同一种语言的特性。
Kotlin中的KClass就是如此，它是一个Kotlin的类，同时它的实例又能作为描述其他类的元数据，像这样用Kotlin描述Kotlin自身信息的行为就是所谓的反射或者自反。
不难看出自反实际上更贴合这个定义也容易理解。
除了Kotlin和Java还有许多的编程语言,如ruby、python等都支持反射技术。
除了我们熟悉的运行时反射之外也有许多语言支持编译期反射，编译期反射通常需要和宏等技术结合使用，编译器将当前程序的信息作为输入传入给宏，并将其结果作为程序的一部分。

+ 8.1.2.2 宏

尽管很多编程语言都支持所谓的“宏”，但他们各自的实现却不那么相同。

学过C语言程序员都知道C语言编译器通常具有一个预处理功能，支持在编译时将相应的宏调用展开成具体内容，实质上就是简单的文本替换。举个简单例子
```C
#define SWAP(a,b) {int _temp = a; a = b; b = _temp}
int main() {
  int i = 0;
  int j = 1;
  SWAP(i, J);
  return 0;
}

```
上述代码定义了交换两个整型的宏SWAP，编译器在SWAP时直接将其替换为`int temp = a; a = b; b = temp`。
这种简单粗暴的方式虽然有时候有效，但存在一个非常严重的问题。上述例子中假如调用宏代码已经定义了名为temp变量则会造成重复定义。

其他诸如Lisp和Scala这样的语言的宏更加的强大，如前文所说，它们会直接在宏展开时暴露抽象语法树(AST)，你可以在宏定义中直接操作这些AST并生成需要的AST作为程序返回。
由于Kotlin目前不支持宏，而且短期内看起来也没有要支持宏的迹象，这里不展开论述这些负杂的宏实现。


+ 8.1.2.3 模板元编程

这可以说时C++的招牌特性，甚至有本名为《Morden C++ Design》的书通篇都是围绕这一特性来展示各种奇技淫巧。C++的模板元编程还具备图灵完备性，理论上可以完成所有的编程任务。由于模板元编程和Kotlin关系并不大，本文不再展开叙述。

+ 8.1.2.4 路径依赖类型

维基百科上将此特性归为一种元编程，支持路径依赖类系的语言通常可以在编译的时候从类型层面避免大部分bug，由于这个特性通常只在一些学术型编程语言如Haskell、Scala中出现，实践中应用并不广泛，我们不在此具体讨论。

## 8.2 Kotlin的反射

反射是大部分程序员都非常熟悉的技术，很多著名的开源框架如Spring之流都不可避免的使用了反射技术。
反射技术的引入可以说是极大增加了Java编程语言的灵活性，使得一些以前难以实现的需求得以实现，大幅减轻了开发人员重复编码的痛苦。
Kotlin既然声称能100%兼容Java，那自然也是支持所有Java支持的反射特性。

### 8.2.1 Kotlin和Java反射

Kotlin被称为更好的Java，显然Java是Kotlin的主要平台，所以本章我们着重讨论Java平台下的Kotlin的反射。
首先通过两张图来对比Kotlin和Java反射基本数据结构。

![Java反射](https://qiniu.drip.im/gh_266a30a8a1f6/20180712111157/upload/e91a6d4626ddfd618466b305b2350e4f33d0d0d2)
<div style="text-align:center">java 反射基本数据结构</div>


![](https://qiniu.drip.im/gh_266a30a8a1f6/20180712114357/upload/160f4ba96aae5a5d840bd371fd3d0b60a5423f62)
<div style="text-align: center">kotlin 反射的基本数据结构</div>

观察上图可以不难发现：

+ Kotlin的KClass和Java的Class可以看作同一个含义的类型，并且是可以通过`.java`和`.kotlin`方法在KClass和Class之间互相转化。
+ Kotlin的KCallable和Java的AccessiableObject都可以理解为可调用元素。Java中构造方法为一个独立的类型，而Kotlin则统一作为KFunction处理。
+ Kotlin的KProperty和Java的Field则不太相同。Kotlin的KProperty通常包含了相应的Getter和Setter（只有可变属性Setter）整体作为一个KProperty，而Java的Field通常仅仅指字段本身。

Kotlin的反射整体来说和Java非常接近，但是需要注意的某些情况下（通常是碰到一些Kotlin独有的特性时）Kotlin编译器会在生产的字节码中存储额外信息，这些信息目前是通过`kotlin.Metadata`注解实现的。Kotlin编译器会将Metadata标注这些类。前文我们提到Kotlin的Lambda没有采用invokeDynamic指令实现，这可能也是一个很大原因。要实现将现有Metadata机制适应新的invokeDynamic指令，显然有巨大的工作量和兼容性问题，稍有不慎就可能会导致bug频出。

整体看来，Kotlin和Java反射非常相似，但得益于Kotlin本身语法简洁的特点，在可读性上还是有很大的提升。本章开头的例子就能充分说明问题。

我们可以将其翻译成等价的Java代码:

```java
public static <A> Map<String, Object> toMap(A a) {
        Field[] fs = a.getClass().getDeclaredFields();
        Map<String, Object> kvs = new HashMap<>();
        Arrays.stream(fs).forEach((f) -> {
            f.setAccessible(true);
            try {
                kvs.put(f.getName(), f.get(a));
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        });
        return kvs;
    }
```
即使是Java8，我们仍然可以看到可读性的提升。我们此处说的可读并不是指代码长度，虽然再更复杂的例子中Kotlin通常能做到更简短，但此处我们考虑可读性是指代码容易理解程度。

+ Kotlin的例子更加直接反应了函数意图：读取所有属性，并将键值对生成Map。
+ Java的例子多了许多额外元素：先读取该类所有字段，创建一个Map，使用stream的forEach来遍历，将每个字段的键值放到map中，返回这个map，同时还需要处理可能的异常。
+ Java版本直接强制访问字段对于值，需强制设置可访问性；而Kotlin版本KProperty的call函数实际上是直接调用Getter，这是更合理的方案。

从内涵来看上述两者是一致的，但是Kotlin代码显然更加容易理解，函数实现直接体现了函数意图；而Java版本则多了额外信息。这也就是我们说的优雅，用更少的元素表达同样或者更多的内涵。

### 8.2.2 Kotlin的KClass

尽管Kotlin的反射和Java非常相似，但是它仍旧有一些独特的地方，主要是集中在Kotlin中独有，Java没有与之对应的特性上。KClass有以下特别属性或者函数：

| 名称                              | 含义                       |
|-----------------------------------|----------------------------|
| isCompanion                       | 是否伴生对象               |
| isData                            | 是否数据类                 |
| isSealed                          | 是否密封类                 |
| objectInstance                    | object实例（如果是object） |
| companionObjectInstance           | 伴生对象实例               |
| declaredMemberExtensionFunctions  | 扩展函数                   |
| declaredMemberExtensionProperties | 扩展属性                   |
| memberExtensionFunctions          | 本类及超类扩展函数         |
| memberExtensionProperties         | 本类及超类扩展属性         |
| starProjectedType                 | 泛型通配类型               |


这些有助于我们实现Kotlin特性相关的反射逻辑，例如获取object实例等。以下这个自然数编码的例子展示了这些用法。

代码

```kotlin
import kotlin.reflect.full.*
sealed  class Nat {

    companion object { object Zero : Nat() }

    val Companion._0
        get() = Zero

    fun <A: Nat> Succ<A>.preceed(): A { return this.prev }
}

data class Succ<N: Nat>(val prev: N) : Nat()

fun <A : Nat> Nat.plus(other: A): Nat = when {
    other is Succ<*> -> Succ(this.plus(other.prev))// a + S(b) = S(a + b)
    else -> this
}
```

我们来看看上述表格中方法的调用结果：

```kotlin

object ReflectionExample {
    @JvmStatic
    fun main(args: Array<String>) {
        println("isCompanion ${Nat.Companion::class.isCompanion}")
        println("isSealed ${Nat::class.isSealed}")
        println("objectInstance ${Nat.Companion::class.objectInstance}")
        println("companionObjectInstance ${Nat::class.companionObjectInstance}")
        println("declaredMemberExtensionFunctions ${Nat::class.declaredMemberExtensionProperties.map { it.name }}")
        println("declaredMemberExtensionFunctions ${Succ::class.declaredMemberExtensionFunctions.map { it.name }}")
        println("memberExtensionFunctions ${Succ::class.memberExtensionFunctions.map { it.name }}")
        println("declaredMemberExtensionProperties ${Nat::class.declaredMemberExtensionProperties.map { it.name }}")
        println("declaredMemberExtensionProperties${Succ::class.declaredMemberExtensionProperties.map { it.name }}")
        println("memberExtensionProperties${Succ::class.memberExtensionProperties.map { it.name }}")
        println("starProjectionType ${Succ::class.starProjectedType}")
    }
}

```

输出

```
isCompanion true
isSealed true
objectInstance nat.Nat$Companion@2473b9ce
companionObjectInstance nat.Nat$Companion@2473b9ce
declaredMemberExtensionFunctions[preceed]
declaredMemberExtensionFunctions[]
memberExtensionFunctions[preceed]
declaredMemberExtensionProperties[_0]
declaredMemberExtensionProperties[]
memberExtensionProperties[_0]
starProjectionType nat.Succ<*>
```

值得一提的是`declaredMemberExtensionFunctions`这类函数返回的结果指的是这个类中声明的扩展函数，而不是在其他位置声明的本类的扩展函数。
例如上面例子中`Nat::class.declaredMemberExtensionFunctions`返回了该类中定义的`Succ.preceed`扩展函数，而没有返回定义在类外的`Nat.plus`函数。
所以这一系列方法作用比较鸡肋，更多时候我们希望获得的是此类扩展方法，遗憾的是目前没有直接方案可以获取某个类的所有扩展函数。

### 8.2.3 Kotlin 的 KCallable
在上文和Java对比的时候我们提到Kotlin把Class中的属性(Property)，函数(Funciton)甚至是构造函数都看做为KCallable，因为它们是可调用的。它们都是Class的成员，那我们如何获取一个Class的成员呢？

幸运的是，上文提到的KClass给我们提供了一个`members`方法，它的返回值就是一个`Collection<KCallable<*>>`，我们先定义一个`Perons` 类，里面有`name`、`age`、`address`等属性，一个空参数函数`isChild`和一个带参数函数`detailAddress`。
```Kotlin
class Person(val name: String, val age: Int, var address: String) {
    fun isChild() :Boolean {
        return this.age <= 18
    }

    fun detailAddress(country: String):String {
        return "$country -> $address"
    }
}
```
我们可以直接运行`println(Person::class.members)`来打印所有的成员，结果如下：
```Kotlin
[var reflect.Person.address: kotlin.String, val reflect.Person.age: kotlin.Int, val reflect.Person.name: kotlin.String, fun reflect.Person.detailAddress(kotlin.String): kotlin.String, fun reflect.Person.isChild(): kotlin.Boolean, fun kotlin.Any.equals(kotlin.Any?): kotlin.Boolean, fun kotlin.Any.hashCode(): kotlin.Int, fun kotlin.Any.toString(): kotlin.String]
```
通过查询结果我们发现，`members`返回的是整个类所有的成员，包含属性和函数。但是某一天你只想筛选所有的属性或者函数该怎么办呢？你可以调用KClass的`memberProperties`方法来获取所有的属性，它的返回值是`Collection<KProperty1<T, *>>`，当然你也可以调用`functions`来获取所有的函数，它的返回值为`Collection<KFunction<*>>`。而`KProperty`和`KFunction`正好是`KCallable`的子类，它们拥有比`KCallabe`更具体的方法。
到此你已经知道如何通过反射来获取Kotlin的KCallabe，接下来我看看KCallabe为我们提供了哪些有用的API：

| API                                  | 描述                      |
|--------------------------------------|---------------------------|
| isAbstract:Boolean<KParameter>       | 此KCallable是否为抽象的   |
| isFinal:Boolean                      | 此KCallable是否为final    |
| isOpen:Boolean                       | 此KCallable是否为open     |
| name:String                          | 此KCallable的名称         |
| parameters: List<KParameter>         | 调用此KCallable需要的参数 |
| returnType:KType                     | 此KCallable的返回类型     |
| typeParameters:List<KTypeParameter\> | 此KCallable的类型参数     |
| visibility:KVisibility?              | 此KCallable的可见性       |
| call(vararg args: Any?): R           | 给定参数调用此KCallable   |

通过对KCallable的API的浏览，你会发现这些API和Java的反射的API很相似，都是对KCallable(Class成员)的信息的获取，你可能对`call`这个函数理解的不够直观，其实它就是调用KCallabe的，下面我们使用`call`来访问Person中的函数和属性。
```Kotlin
 fun CallFunctionShow() {
    val p = Person("极跑科技",8,"HangZhou")
    // 调用函数
    for(c in Person::class.functions) {
        when {
            c.name.equals("isChild") -> println(c.call(p))
            c.name.equals("detailAddress") -> println(c.call(p, "China"))
        }
    }
    // 访问属性
    for(c in Person::class.memberProperties) {
        println(c.call(p))
    }
}
```
运行的结果如下：
```Kotlin
China -> HangZhou
true
HangZhou
8
极跑科技
```
我们发现`call`函数和Java的`Method.invoke(...)`方法的用法差不多，需要传递类的实例和参数才可以调用。对于空参数函数你只需要传递一个类的实例即可调用，而对于多参数函数，你的第一个参数需要为类的实例，后面的参数才为函数需要的参数。

+ 8.2.3.1 KMutableProperty
有时候我们不仅仅想使用反射来获取一个类的属性，而且我们还想更改它的值，在Java中你可以通过`Field.set(...)`来完成对字段的更改操作，但是在Kotlin中，并不是所有的属性都是可变的，因此我们只能对那些可变的属性进行修改操作。通过前面那张Kotlin反射数据结构图我们知道，`KMutableProperty`是`KProperty`的一个子类，那我们如何识别一个属性是`KMutableProperty`还是`KProperty`呢？在第五章我们学过模式匹配，我们使用模式匹配可以轻松的解决这个问题。还是拿上面的`Person`类作为例子，我们想把`address`属性的值改为`Hefei`,如何去做呢？

```Kotlin
fun KMutablePropertyShow() {
    val p = Person("极跑科技",8,"HangZhou")
    val props = p::class.memberProperties
    for(prop in props){
       when(prop) {
           is KMutableProperty<*> -> prop.setter.call(p,"Hefei")
           else -> prop.call(p)
       }
    }
    println(p.address)

}
```
运行的结果为`Hefei`，我们已经通过反射成功的修改了`address`的值。再去仔细的看一下Kotlin官方关于`KMutableProperty`的API，发现只比`KProperty`多了一个setter函数。

### 8.2.4 Parameter
到此我们已经介绍了如何使用反射来获取Kotlin中的类、属性和函数，让我们在走近一些，看看如何使用Kotlin的反射来获取参数信息。Kotlin把参数分为三个类别，它们分别是函数的参数(`KParameter`)，函数的返回值(`KType`)以及类型参数(`KTypeParameter`)。下面我们就来看看如何获取它们以及它们的用法。

+ 8.2.4.1 KParameter
使用`KCallabel.parameters`即可获取一个`List<KParameter>`，它代表的是函数(包括扩展函数)的参数，让我们先来浏览一下它的API:

| API                                  | 描述                            |
|--------------------------------------|---------------------------------|
| index:Int                            | 返回该参数在参数列表里面的index |
| isOptional:Boolean                   | 该参数是否为Optional            |
| isVararg:Boolean                     | 该参数是否为vararg              |
| kind:Kind                            | 该参数的kind                    |
| name:Sting?                          | 该参数的名称                    |
| type:KType                           | 该参数的类型                    |

我们还是使用上面的`Person`类来打印一下所有`KCallable`的参数的类型，代码如下：
```Kotlin
fun KParameterShow() {
    val p = Person("极跑科技",8,"HangZhou")
    for(c in Person::class.members) {
        print("${c.name} -> ")
        for(p in c.parameters){
           print("${p.type}" + " -- ")
        }
        println()
    }
}
```
运行结果：
```Kotlin
address -> reflect.Person --
age -> reflect.Person --
name -> reflect.Person --
detailAddress -> reflect.Person -- kotlin.String --
isChild -> reflect.Person --
equals -> kotlin.Any -- kotlin.Any? --
hashCode -> kotlin.Any --
toString -> kotlin.Any --
```
通过上面的运行结果，我们发现对于属性和无参数的函数，它们都有一个隐藏的参数为类的实例，而对于声明参数的函数，类的实例作为第一个参数，而声明的参数作为后续的参数。对于那些从`Any`继承过来的参数，Kotlin默认它们的第一个参数为`Any`。

+ 8.2.4.2 KType
聊完成了`KCallable`的参数类型，我们来聊聊`KCallable`的返回值类型，和参数类型一样，每一个`KCallabe`都可以使用`returnType`来获取返回值类型，它的结果类型是一个`KType`,代表着Kotlin中的类型。它的API如下：

| API                             | 描述                                                                                              |
|---------------------------------|---------------------------------------------------------------------------------------------------|
| arguments:List<KTypeProjection> | 该类型的类型参数                                                                                  |
| classifier:KClassifier?         | 该类型在类声明层面的类型，如该类型为List<String>,那么通过 classifier 得到结果为List(忽略类型参数) |
| isMarkedNullable:Boolean        | 该类型是否标记为可空类型                                                                          |

还是使用`Person`类来做演示，这里我们在`Person`类中添加了一个返回值为`List<String>`的`friendsName`方法，用来演示`classifiler`API,代码如下：
```Kotlin
fun friendsName(): List<String> {
    return  listOf("Yiso", "Jilen")
}
```

我们的演示代码如下：
```Kotlin
fun KTypeShow() {
    for(c in Person::class.members) {
        print("${c.name} -> ")
        val rp = c.returnType
        println("classifier -> ${rp.classifier}")
    }
}
```
运行结果如下：
```Kotlin
address -> classifier -> class kotlin.String
age -> classifier -> class kotlin.Int
name -> classifier -> class kotlin.String
detailAddress -> classifier -> class kotlin.String
friendsName -> classifier -> class kotlin.collections.List
isChild -> classifier -> class kotlin.Boolean
equals -> classifier -> class kotlin.Boolean
hashCode -> classifier -> class kotlin.Int
toString -> classifier -> class kotlin.String
```
通过对运行结果的分析，我们发现`classifier`API其实就是获取该参数在类层面对应的类型，如`Int -> class kotlin.Int`，`List<String> -> class kotlin.collections.List`

+ 8.2.4.3 KTypeParameter
对于函数和类来说，还一个重要的参数——类型参数，在`KClass`和`KCallable`我们可以通过`typeParameters`来获取class和callable的类型参数，它返回的结果集是`List<KTypeParameter>`，对于不存在类型参数的就返回一个空的List。在之前的`Person`中我们添加一个带类型参数的方法，代码如下：
```Kotlin
 fun <A> get (a: A): A {
   return a
}
```
然后我们可以使用下面的代码来获取`get`方法和`List<String>`的类型参数：
```Kotlin
fun KTypeParameterShow() {
    for (c in Person::class.members) {
        if(c.name .equals("get")) {
            println(c.typeParameters)
        }
    }
    val list = listOf<String>("How")
    println(list::class.typeParameters)
}
```
运行的结果如下：
```Kotlin
[A]
[E]
```
通过运行的结果，我们已经获取到了方法和类上面的类型参数。

### 8.2.5 Kotlin反射和Java的相互操作
众所周知，Kotlin的强大之处在于和Java的相互操作，上文我们曾经说过，可以使用`KClass.java` 方法来实现`KClass`到Java`Class`的转换。例如我们有一个`Student`的Java类，代码如下：
```Java
public class Student {
    public Student(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    private  String name;
    private Integer age;

    public String getName() {
        return name;
    }

    public Integer getAge() {
        return age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age='" + age + '\'' +
                '}';
    }

}
```

然后我们使用Java反射来获取类字段的值，代码如下：
```Kotlin
fun interoperableWithJava() {
    val s  = Student("Jilen",30)
    val javaClass =  Student::class.java // 产生一个Java的Class对象
    for (c in javaClass.declaredFields) {
        c.setAccessible(true) // 强行访问私有字段的值
        println(c.get(s))
    }
}
```

运行结果如下：
```Kotlin
Jilen
30
```
通过`KClass.java`方法我们可以获取一个对于的Java的Class对象，然后我们就可以为所欲为的调用Java的各种反射API来完成一些Kotlin不推荐的操作，如强制访问私有字段的值。

到此我们已经介绍完了Kotlin反射相关的知识点，如果你在使用Kotlin反射的过程中遇到任何困得，可以第一时间去Kotlin的官方反射文档：https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/index.html 寻找答案。下面我们将会介绍注解，注解的解析就是使用反射来实现的，我们一起去看看吧。


## 8.3 Kotlin的注解

前面我们提及过注解`kotlin.Metadata`，这是实现Kotlin大部分独特特性反射的关键，Kotlin将这些信息直接以注解形式存储在字节码文件中以便运行时反射可以获取这些数据。
由于Kotlin兼容Java，所以所有Java可以添加注解的地方，Kotlin也都可以。并且Kotlin也简化了注解创建语法，创建注解就像创建class一样简单，只需额外在class前增加annotation关键字。

```kotlin
annotation class FooAnnotation(val bar: String)
```
上面代码就直接创建了`FooAnnotation`注解，和创建其他Kotlin的类一样，正如前文所说只要在前面加上annotation，这个类就变成了注解。和等价的Java代码相比较，确实简化了很多。同时和Java一样，注解的参数只能是常量，并且仅支持下列类型

+ 于Java对应的基本类型
+ 字符串
+ Class对象(KClass或者Java的Class)
+ 其他注解
+ 上述类型数组。注意基本类型数组需要指定为对应的`XXXArray`，例如`IntArray`，而不是`Array<Int>`。

有了注解之后我们就可以将注解应用在代码中，那么哪些代码可以添加注解呢？熟悉Java的读者应该已经想到了`@Target`元注解，它可以指定注解作用的位置。类似`@Target`这样标注在注解上的注解我们称之为元注解。Java有下列5个元注解

+ Documented 文档（通常是API文档）中必须出现该注解。
+ Inherited 如果超类标注了该类型，那么其子类型也将自动标注该注解而无需指定。
+ Repeatable 这个注解在同一位置可以出现多次。
+ Retention 表示注解用途，有三种取值：
  - `Source`仅在源代码中存在，编译后class文件中不包含该注解信息。
  - `CLASS`class文件中存在该注解，但不能被发射读取。
  - `RUNTIME`注解信息同样保存在class文件中并且可以在运行时通过反射获取。
+ Target 表明注解可应用于何处。

类系的Kotlin也有相应的元注解在kotlin.annotation包下：

| Kotlin                       | Java                            |
|------------------------------|---------------------------------|
| kotlin.annotation.Retention  | java.lang.annotation.Retention  |
| kotlin.annotation.Target     | java.lang.annotation.Target     |
| kotlin.annotation.Documented | java.lang.annotation.Documented |
| kotlin.annotation.Repeatable | java.lang.annotation.Repeatable |

注意到Kotlin目前不支持Inherited，理论上实现继承没有很大难度，当时当前版本还不支持。
通过上面对比，我们发现Kotlin和Java注解整体上是保持一致的，熟悉Java注解的读者应该很容易将这部分知识迁移到Kotlin。同样的，Kotlin也有`@Target`元注解，和Java相似它控制注解可以作用的位置。


### 8.3.1 无处不在的注解

和Java一样Kotlin的注解可以出现代码的各个位置，例如方法、属性、局部变量、类等等。此外注解还能作用于Lambda表达式、整个源文件。
前文已经指出Java注解标注的位置可以通过元注解`@Target`指定，Kotlin也一样，并且Kotlin在Java的基础上增加一些可以标注的位置，**这些位置是在`AnnotationTarget`枚举中定义的**，我们只需看看`AnnotationTarget`有多少种取值就能知道它能作用于多少个位置

| Kotlin(AnnotationTarget) | Java(Target)    | 说明                                           |
|--------------------------|-----------------|------------------------------------------------|
| CLASS                    | TYPE            | 作用于类                                       |
| ANNOTATION_CLASS         | ANNOTATION_TYPE | 作用于注解本身（即元注解）                     |
| TYPE_PARAMETER           | TYPE_PARAMETER  | 作用于类型参数                                 |
| PROPERTY                 | NA              | 作用于属性                                     |
| FIELD                    | FIELD           | 作用于字段（属性通常包含字段Getter以及Setter） |
| LOCAL_VARIABLE           | LOCAL_VARIABLE  | 作用于局部变量                                 |
| VALUE_PARAMETER          | NA              | 作用于val参数                                  |
| CONSTRUCTOR              | CONSTRUCTOR     | 作用于构造函数                                 |
| FUNCTION                 | METHOD          | 作用于函数(Java只有Method)                     |
| PROPERTY_GETTER          | NA              | 作用于Getter                                   |
| PROPERTY_SETTER          | NA              | 作用于Setter                                   |
| TYPE                     | TYPE_USE        | 作用于类型                                     |
| EXPRESSION               | NA              | 作用于表达式                                   |
| FILE                     | PACKAGE         | 作用于文件开头/包声明（两者有细微区别）        |
| TYPEALIAS                | NA              | 作用于类型别名                                 |

观察上表不难发现Kotlin支持几乎所有Java可以标注的位置，并且增加了一些Kotlin独有的位置。
下面就是一个简单Kotlin注解使用例子

```kotlin
annotation class Cache(val namespace: String, val expires: Int)
annotation class CacheKey(val keyName: String, val buckets: IntArray)


@Cache(namespace = "hero", expires = 3600)
data class Hero(
        @CacheKey(keyName = "heroName", buckets = intArrayOf(1,2,3))
        val name: String,
        val attack: Int,
        val defense: Int,
        val initHp: Int
)
```

细心的读者可能已经发现Kotlin的代码常常会表达多重含义。例如，上述例子中的`name`除了生成了一个不可变的字段之外实际上还包含了Getter，同时又是其构造函数的一个参数。
这就带来一个问题，`@CacheKey`注解究竟是作用于何处？

#### 8.3.2 精确控制注解的位置

为了解决这个问题，Kotlin引入下列精确的注解控制语法

假如我们有注解`annotation class CacheKey`

| 用法               | 含义                                 |
|--------------------|--------------------------------------|
| @file:CacheKey     | CacheKey注解作用于文件               |
| @property:CacheKey | CacheKey注解作用于属性               |
| @field:CacheKey    | CacheKey注解作用于字段               |
| @get:CacheKey      | CacheKey注解作用于Getter             |
| @set:CacheKey      | CacheKey注解作用于Setter             |
| @receiver:CacheKey | CacheKey注解作用于扩展函数或属性     |
| @param:CacheKey    | CacheKey注解作用于构造函数参数       |
| @setparam:CacheKey | CacheKey注解作用Setter的参数         |
| @delegate:CacheKey | CacheKey注解作用于存储代理实例的字段 |


例如
```kotlin
@Cache(namespace = "hero", expires = 3600)
data class Hero(
        @property:CacheKey(keyName = "heroName", buckets = intArrayOf(1, 2, 3))
        val name: String,
        @field:CacheKey(keyName = "atk", buckets = intArrayOf(1, 2, 3))
        val attack: Int,
        @get:CacheKey(keyName = "def", buckets = intArrayOf(1, 2, 3))
        val defense: Int,
        val initHp: Int
)
```
上述CacheKey注解分别作用在熟悉，字段和Getter上


### 8.3.3 获取注解信息

代码标记上注解之后，注解本身也成了代码的一部分，我们自然而然就会想到如何利用这些注解信息。Kotlin当然也提供方法获取注解信息

+  通过反射获取注解信息

一个自然而然的方案是通过反射去获取注解信息，这有一个前提就是这个注解的`Retentaion`标注为`Runtime`或者没有显示指定（注默认为`Runtime`）。前文中我们已经了解到如何通过反射获取类及其成员，获取了这些数据之后，很容易就可以通过api获取其注解信息。如：
```Kotlin
annotation class Cache(val namespace: String, val expires: Int)
annotation class CacheKey(val keyName: String, val buckets: IntArray)


@Cache(namespace = "hero", expires = 3600)
data class Hero(
        @CacheKey(keyName = "heroName", buckets = intArrayOf(1,2,3))
        val name: String,
        val attack: Int,
        val defense: Int,
        val initHp: Int
)

fun main(args: Array<String>) {
    val cacheAnnotion = Hero::class.annotations.find{ it is Cache} as Cache?
    println("namespace ${cacheAnnotion?.namespace}")
    println("expires ${cacheAnnotion?.expires}")
}
```
显而易见，通过反射获取注解信息是在运行时发生的，和Java一样存在一定的性能开销，当然这种开销大部分时候可以忽略不计。

+ 8.3.3.2 注解处理器

众所周知，JSR269引入了注解处理器（annotation processors），允许我们在编译过程中挂钩子实现代码生成，得益于此，如dagger之类的框架实现了编译时依赖注入这样原本只能通过运行时反射支持的特性。

在了解什么是注解处理器之前，我们先来看看编译器的主要工作:

![编译器工作原理](https://qiniu.drip.im/gh_266a30a8a1f6/20180712111758/upload/ed91f093df924fb44e22b488ed8663cca813a848)
如图所示，我们可以把编译器看成一个输入为源文件，输出为目标文件的程序。这个程序的第一步是将源文件解析为AST（抽象语法树），实现这部分的程序通常被称为解析器（parser）。
解析器解析完毕后会将AST传给注解处理器。

> 需要澄清一点，JSR269脱胎于javac，对于eclipse ecj之类的编译器通常有自己的AST，它需要额外适配到JSR269定义的AST

这里本来应该是代码生成的最佳场合，理论上应该可以实现对AST进行修改，然而JSR269是只读API，这就限制了你不能修改任何传入给注解处理器的AST。如果要实现代码生成，只能非常蹩脚的将代码以字符串形式写入另一个文件，这不得不说是一个非常大遗憾。

下面是一个具体来看一个例子：

```kotlin
import javax.annotation.processing.*
import javax.lang.model.element.ElementKind
import javax.lang.model.element.TypeElement
import kotlin.reflect.full.memberProperties
import javax.tools.JavaFileObject


annotation class MapperAnnotation

class MapperProcessor : AbstractProcessor() {


    private fun genMapperClass(pkg: String, clazzName: String, props: List<String>): String {
        TODO()
    }

    override fun process(set: MutableSet<out TypeElement>?, env: RoundEnvironment?): Boolean {
        val el = env?.getElementsAnnotatedWith(MapperAnnotation::class.java)?.firstOrNull()
        if (el?.kind == ElementKind.CLASS) {
            val pkg = el.javaClass.`package`.name
            val cls = el.javaClass.simpleName
            val props = el.javaClass.kotlin.memberProperties.map { it.name }
            val mapperClass = genMapperClass(pkg, cls, props)
            val jfo = processingEnv.filer.createSourceFile(
                    cls + "Mapper")
            val writer = jfo.openWriter()
            writer.write(mapperClass)
            writer.close()

        }
        return true;
    }
}

```

这个例子中我们根据Mapper注解获取对应的类系信息，并生成一个XXXMapper类，里面实现自动转化为Mapper的方法。可以看到，Annotation Processor没有能力直接修改AST而只能创建一个文件，并将代码写入该文件。
就像上面的geMapperClass函数我们只能以字符串形式生成Java代码
```kotlin
private fun genMapperClass(pkg: String, clazzName: String, props: List<String>): String {
       return """
            package $pkg;
            import java.util.*;
            public class ${clazzName}Mapper {
                public Map<String, Object> toMap($clazzName a) {
                  Map<String, Object> m = new HashMap<String, Object>();
                  ${
                   props.map {
                      "m.put(\"${it}\",a.${it})"
                   }
                }
            }
        """
    }

```

注解处理器的使用方法也和Java一样

+ 第一步：添加注解处理器信息。这需要在classpath里包含META-INFO/services/javax.annotation.processing.Processor文件，并将注解处理器包名和类名写入该文件。
+ 第二步：使用kapt插件。如果是gradle工程可以通过`apply plugin: 'kotlin-kapt'`添加注解处理器支持。

> Kapt也支持生成Kotlin代码。如上述例子中，我们可以将genMapperClass中的代码替换为Kotlin代码，并且将其存储在`processingEnv.options["kapt.kotlin.generated"]`目录中。

虽然annotation processor允许开发人员访问程序AST，但没有提供行之有效的代码生成方案，目前仅有的代码生成方案也仅仅是将代码以字符串的形式写入新文件，而无法做到直接将生成的AST作为程序。这也说明了Java和Kotlin目前不具备同像性。

## 8.5 使用反射和注解来实现ORM
在本节中，我将使用Kotlin的反射和注解来实现ORM，如果你对Java的反射和注解很熟悉，而且有一些实战经历，那么你可以轻轻浏览或者跳过本节的内容。如果你对Java的反射不是很了解，那么通过本节对Kotlin反射和注解的学习，你将会了解到反射和注解在实际项目发挥的重要作用。在正式介绍本节的内容之前，我们先来了解一下ORM。
> ORM：对象关系映射，是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。如今已有很多免费和付费的ORM产品，而有些程序员更倾向于创建自己的ORM工具。(维基百科)

如果你是后端工程师，那么即使你没有听说过ORM，但是你肯定使用过。说白了就是把关系数据库的表映射为对象。Java中的Hibernate、MyBatis框架以及Scala中的Quill框架都有着此功能。你把SQL和参数传递给框架，框架映射给你一个对应的JavaBean对象。

如果你是一名安卓工程师，那么在阅读本节时，对于数据库相关的知识，如果看不懂可以直接跳过，着重去理解Kotlin如何通过反射来创建一个对象并返回的过程。
既然是ORM，那肯定得有数据库表吧，这里我们的表如下：
```SQL
create table person (
  id int(11) not null primary key auto_increment,
  name varchar(64) not null,
  age int(3) not null,
  address varchar (255) not null,
  job varchar(255) default null
);
```
你只要对数据库有所了解，那么这张表就极为简单，我们创建一张`person`表，里面的字段相信大家都能看得懂，为了后续我们查询方便，我们再准备一条`insert`SQL:
```SQL
insert into person values (1,'How',23,'Hangzhou','programmer');
```
关系数据表有了，接下来我们该创建一个对象与之匹配了，在Kotlin中，我推荐使用`data class`来作为数据类。一方面是因为它的语法简洁，另一方是因为它更纯粹表达它是一个存储数据的容器，而不是一个其它的什么类。在Java中，我们总是通过包名来区分，例如在`domain`包下的类就是和数据库进行ORM的类，在`service`包下面的类就是整个工程的Service。
```Kotlin
data class Person(
        val id: Long,
        val name: String,
        val age: Int,
        val address: String,
        val job: String
)
```
现在我们已经有了数据表和Class，那么我们就着手来完成它们的映射吧。
### 8.5.1一个简单的查询操作
`映射`这个词很大，而且让人看起来有点慌，那么我们把问题简化，这里我们只做给`queryByIdWithSQL`函数一条查询的SQL语句和参数，让它给我们返回一个data class。到这里，可能还是会有点摸不着头脑，怎么操作数据库？如何完成数据库的结果集和data class的映射？我们先不管那么多，我们先把`queryByIdWithSQL`函数的签名确定。

因为我们不仅仅是对`Person`类做映射，后面可能还有`Student`类等等，因此我们需要写一个通用的`queryByIdWithSQL`函数。还记得我们在第五章学过的泛型吗，它就是用来设计通用方法的一个重要的类型。因此初步的函数签名如下：
```Kotlin
fun <R> queryByIdWithSQL(sql: String, vararg args: Any?): R?
```

方法签名解决了，那我们先尝试着来实现它的函数体，对于数据库的操作我们先不不管，我们先来解决如果通过泛型`R`来创建一个`R`的实例。你第一时间想到的是通过上面的反射来完成。于是你很开心的在方法体里面使用`R :: class`，但是不幸的是，编译器却给你一个报错。这很正常，因为JVM在编译时会进行类型擦除，而在运行时，你是无法知道`R`的类型究竟是什么，编译器给你报错也是理所应当，还记得在第五章我们学过的内联吗？使用内联函数就可以解决这个问题，因此我们新的函数签名如下：
```Kotlin
inline  fun <reified R> queryByIdWithSQL(sql: String, vararg args: Any?): R?
```
到此我们终于可以在函数体里面使用`R :: class`来获取`R`的KClass，但是我们如何创建一个`R`的实例呢？其实我们可以通过调用构造方法来获取`R`的实例。对于data class，一般就只有一个主构造函数，我们可以使用`R :: class.constructors.first()`来获取，但是想要调用这个函数，我们需要给它传递一个`Map<KParameter, Any?>`，key 为构造函数对应的参数，value为参数对应的实例(值)。`KParameter`我们可以使用`R :: class.constructors.first().parameters`轻松获取，而值不就是我们从数据库查询出来的结果集吗？很快我们就有了灵感，于是代码如下：

```Kotlin
inline  fun <reified R> queryByIdWithSQL(sql: String, vararg args: Any?): R? {
        val pstmt = getConnection().prepareStatement(sql)
        args.forEachIndexed { index, item -> pstmt.setObject(index+1,item) }
        val rs = pstmt.executeQuery()
        val constructor = R :: class.constructors.first()
        val cParams = constructor.parameters
        return  if (rs.next()) {
            val params = cParams.map { it to rs.getObject(it.name) }.toMap()
            constructor.callBy(params) as R
        } else {
            null
        }
    }
```
这里我们使用原始的Java操作数据的方式，并且遵循数据表中的字段名称和data class中的属性名称一致。这样我们可以通过`rs.getObject(parameterName)`来完成数据库表和data class 之间的映射，并且最终通过调用构造函数的`callBy`方法来完成对R实例的创建。

到此你可能想很想运行这段代码，但是你可能会为数据库的安装而苦恼。没关系，在我这里，你不需要安装数据。你需要先建立一个Gradle的Kotlin工程，并且在`build.gradle`文件中添加如下依赖：
```txt
compile "org.jetbrains.kotlin:kotlin-stdlib-jdk8"
    testCompile group: 'junit', name: 'junit', version: '4.12'
    // https://mvnrepository.com/artifact/com.h2database/h2
    testCompile group: 'com.h2database', name: 'h2', version: '1.4.196'
    // https://mvnrepository.com/artifact/org.jetbrains.kotlin/kotlin-reflect
    compile group: 'org.jetbrains.kotlin', name: 'kotlin-reflect', version: '1.2.21'
```
这里我们使用`h2database`数据库驱动，它是一个基于内存的数据库，它可以帮你在内存中虚拟一个数据库，而且你可使用编程语言来操作它，不需要安装一个实际的数据库，只需要你在获取`Connection`时指定编写SQL的文件，代码如下：
```Kotlin
public fun getConnection(): Connection {
        Class.forName("org.h2.Driver")
        val db = "jdbc:h2:mem:;INIT=runscript from 'classpath:/person.sql'"
        return DriverManager.getConnection(db)
    }
```
这里我们只是简单的获取一个数据库的`Connection`，如果你觉得这样获取不好，可以使用一些开源的连接池。
配置中的最后一个依赖可能引起了你的注意，这不是Kotlin的反射依赖吗？确实是。因为Kotlin在Gradle工程中默认不携带反射包，因此你想运行和反射相关的代码，就必须先安装依赖。
如果你觉得配置gradle工程很麻烦，我也给你们留了参考的GitHub地址：https://github.com/KnewHow/kotlin-orm

### 8.5.2一个不完美的地方
在上述的`queryByIdWithSQL`方法中有两个不完美的地方：
* 需要手动去写SQL语句
* 数据库表的字段名称必须和data class的属性名称一致。

而实际开发过程中，对于简单的查询操作，我们一般不写SQL语句，而且数据库表的字段名称和data class并不总是一致的。能不能建立一种data class和数据库表之间的映射？并且在运行时自动的为我们生成SQL语句。

#### 使用注解来完成映射
对于SQL语句而言，能变的参数只有两个，表名称和字段名称，而data class正好也有对于的两个变量，类名称和属性名称，那我们如何建立它们之间的映射关系呢？还记得在上一小节中我们学过的注解吗？它可以帮助我们实现映射关系。在函数中，我们可以访问`R`类上的注解和属性上的注解以此来获取我们想要的数据库表名称和字段名称。为了实现上述的需求，我们需要定义三个注解，它们分别是表示表名称的注解`Table`，表示主键的注解`Id`以及表示字段的注解`Column`，代码如下：
```Kotlin
annotation class Table (val name: String="")

annotation class Id (val name: String="")

annotation class Column(val name: String="")
```
这里我们给予注解属性默认值`""`，这意味着当我们不给注解属性赋值时，类名称和属性名称就是对应的表名称和字段名称。按照第一个例子的套路，我们先来完成对函数`queryByIdNOSQL`的签名，既然没有SQL，那么函数签名就简单很多，直接给出查询所需要的参数即可：
```Kotlin
inline  fun<reified  R> queryByIdNOSQL(vararg args: Any): R?
```
对于表名称，我们可以通过类上的注解来获取，代码如下：
```Kotlin
public fun getTableName(clazz: KClass<*>): String? {
        val tableAnno = clazz.annotations.find { it is Table } as? Table
        return  tableAnno?.name ?: clazz.simpleName
    }
```
因为是根据Id查询，所以我们需要获取有`Id`注解的属性，并获取注解的属性`name`的值，代码如下：
```Kotlin
public fun getIdName(clazz: KClass<*>): Pair<String, String> {
        val idProp = clazz.memberProperties.filter { (it.annotations.filter { a -> a is Id }).isNotEmpty()  }.firstOrNull()
        val idAnno =  idProp?.annotations?.find { it is Id } as? Id
        val name = idAnno?.name
        return  if(name == null || name == "") {
            (idProp!!.name to idProp!!.name)
        } else {
            (idProp!!.name to name)
        }
}
```
除了Id之外，我们还需要获取data class其它属性和数据表字段的映射关系，我们使用一个Map集合来封装它们，key为data class 属性名称，value为对应的数据库字段名称，代码如下：
```Kotlin
  public  fun getProp2Column(clazz: KClass<*>): Map<String,String> {
        return clazz.memberProperties.map { it.name to getColumnName(it) }.toMap()
  }

  public fun getColumnName(prop: KProperty<*>): String  {
        val columnAnno = prop.annotations.find { it is Column } as? Column
        val name = columnAnno?.name
        return if(name == null || name == "") {
            prop.name
        } else {
            name
        }
    }
```
#### 根据映射来生成SQL

到此我们已经完成了data class到数据库表的映射，剩下的事情就是根据映射来自动生成SQL语句，这应该是最简单的事情了：
```Kotlin
public fun createSQL(clazz: KClass<*>, tbName: String, idName: String, prop2Column: Map<String, String>): String {
        val sql = StringBuffer("select ")
        clazz.memberProperties.forEach{ sql.append(prop2Column.get(it.name) + ",")}
        sql.deleteCharAt(sql.length-1)
        sql.append(" from $tbName where $idName = ?")
        return  sql.toString()
}
```
有了上面的方法做铺垫，`queryByIdNOSQL`的函数体就应该很容易就写出来了：
```Kotlin
  inline  fun<reified  R> queryByIdNOSQL(vararg args: Any): R? {
        val tbName = getTableName(R::class)
        val idPair = getIdName(R::class)
        val prop2ColumnMap = getProp2Column(R::class).toMutableMap()
        prop2ColumnMap.put(idPair.first,idPair.second)
        return if(tbName==null) {
            null
        } else {
            val sql = createSQL(R::class,tbName,idPair.second,prop2ColumnMap)
            queryORM<R>(sql,prop2ColumnMap,args.toList())
        }
    }
```
`queryORM`方法就是去查询数据并把结果映射到data class，和第一个例子一样，只是再从查询结果集中获取字段的值时，需要根据我们生成的映射关系来获取，代码如下：
```Kotlin
inline fun<reified R> queryORM(sql: String,prop2Column: Map<String, String>,args:List<Any?>):R? {
        val pstmt = getConnection().prepareStatement(sql)
        args.forEachIndexed { index, item -> pstmt.setObject(index+1,item) }
        val rs = pstmt.executeQuery()
        val constructor = R :: class.constructors.first()
        val cParams = constructor.parameters
        return  if (rs.next()) {
            val params = cParams.map { it to rs.getObject(prop2Column.get(it.name)) }.toMap()
            constructor.callBy(params) as R
        } else {
            null
        }
}
```
### 编写测试用例并运行
到此我们已经编写好符合需求的方法，此时我们需要测试它，我们把我们的person表中的`name`修改为`pname`，如果使用之前的方法就会报错，即使你的SQL语句书写正确，但是我们可以给data class 加上注解来完成ORM，而且还不用写SQL语句，多么舒服的一件事情啊。
```SQL
create table person (
  id int(11) not null primary key auto_increment,
  pname varchar(64) not null,
  age int(3) not null,
  address varchar (255) not null,
  job varchar(255) default null
);
insert into person values (1,'How',23,'Hangzhou','programmer');
```
使用注解后的data class：
```Kotlin
package orm.test.model

import annotations.Column
import annotations.Id
import annotations.Table

@Table("person")
data class Person(
        @property:Id("id")
        val id: Long,
        @property:Column("pname")
        val name: String,
        @property:Column
        val age: Int,
        @property:Column
        val address: String,
        @property:Column
        val job: String
)
```
我们把方法使用`Quote`对象来封装，使用Junit编写测试用例如下：
```Kotlin
class ORMTest {
    @Test
    fun testQueryByIdNeedSQL() {
        val s = "select * from person where id = ?"
        var r = Quote.queryByIdWithSQL<Person>(s,1)
        println(r)
    }

    @Test
    fun testQueryByIdNOSQL() {
        val r = Quote.queryByIdNOSQL<Person>(1L)
        println(r)
    }

}
```

运行第二个测试方法的结果如下，可以看到数据库表中字段为`pname`的值被成功的映射到data class的`name`属性：
```Kotlin
Person(id=1, name=How, age=23, address=Hangzhou, job=programmer)
```
通过这个简单的ORM例子，我们可以窥探到反射和注解在设计內库的时候有多么方便的作用，除此之外，我们还见识到了一些ORM框架底层的实现机理。如果你有兴趣，可以接着去完善`INSERT`或者`UPDATE`等其它的ORM。

## 8.5 本章小结
- **元编程**
编程语言自身描述自身的一种手段，主要分为运行时期的元编程和编译时期的元编程，不同的编程语言对它们的支持程度不尽相同。

- **Kotlin反射**
Kotlin目前只支持运行时期的元编程——反射，涉及的类有主要有`KClass`，`KCallable`，`KParameter`，`KFunction`，`KProperty`等，在文章中我们已经详细介绍了它们的用法。总得来说Kotlin的元编程和Java的非常接近，但得益于本身语法特性，Kotlin的反射API使用更加简洁高效。

- **注解**
一种可以代替配置文件的手段，可以通过反射在运行期间获。在文章中我们具体介绍了如何定义以及使用注解，以及如何控制注解作用的位置。

- **注解处理器**
介绍了注解处理器的原理和使用方法，但是比较遗憾的是Kotlin目前和Java一样没有简单优雅的代码生成方案，开发人员要么通过注解处理器手工将代码写入文件，要么直接依赖javac的tree api牺牲可移植性。这两种方案不管那种都不是很理想，使用起来颇为费力。

- **ORM实战**
使用注解来完成数据库字段和data class属性的映射，使用反射来完成data class实例的创建，而二者结合使用可以实现一套完整的ORM。通过此案例来加深对Kotlin反射和注解的理解，顺便窥探在类库设计中Kotlin反射和注解发挥的重大作用。
